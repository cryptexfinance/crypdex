{
  "address": "0xa080Cb3fC64CA26F93AfEBC78Ea6a2beB734B6f5",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_scalingFactor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_timeCoefficient",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minPrice",
          "type": "uint256"
        }
      ],
      "name": "areParamsValid",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "getDecodedData",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "scalingFactor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "timeCoefficient",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isDecreasing",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minPrice",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_scalingFactor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_timeCoefficient",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "_isDecreasing",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "_maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minPrice",
          "type": "uint256"
        }
      ],
      "name": "getEncodedData",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_timeElapsed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_priceAdapterConfigData",
          "type": "bytes"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_priceAdapterConfigData",
          "type": "bytes"
        }
      ],
      "name": "isPriceAdapterConfigDataValid",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isValid",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x1eccf6398c2d34bf203ac7e45a569b66357c7a7d387ce2f8164465d18e53a1f4",
  "receipt": {
    "to": null,
    "from": "0xf8Bd793A7c9cB86e827C084D49f343F1296a8247",
    "contractAddress": "0xa080Cb3fC64CA26F93AfEBC78Ea6a2beB734B6f5",
    "transactionIndex": 5,
    "gasUsed": "621056",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd39424fa0ce317966c8fb69970eb0182db20e151a7c5026b22ec5055f1a82abe",
    "transactionHash": "0x1eccf6398c2d34bf203ac7e45a569b66357c7a7d387ce2f8164465d18e53a1f4",
    "logs": [],
    "blockNumber": 311511514,
    "cumulativeGasUsed": "3906831",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "c59476410df9927d260451178dd2183d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_scalingFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeCoefficient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"areParamsValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"getDecodedData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scalingFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCoefficient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDecreasing\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_scalingFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeCoefficient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDecreasing\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"getEncodedData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeElapsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_priceAdapterConfigData\",\"type\":\"bytes\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_priceAdapterConfigData\",\"type\":\"bytes\"}],\"name\":\"isPriceAdapterConfigDataValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Index Coop\",\"kind\":\"dev\",\"methods\":{\"areParamsValid(uint256,uint256,uint256,uint256,uint256,uint256)\":{\"details\":\"Returns true if the price adapter parameters are valid.\",\"params\":{\"_bucketSize\":\"Time elapsed between each bucket\",\"_initialPrice\":\"Initial price of the auction\",\"_maxPrice\":\"Maximum price of the auction\",\"_minPrice\":\"Minimum price of the auction\",\"_scalingFactor\":\"Scaling factor for logarithmic expression\",\"_timeCoefficient\":\"Scaling factor for logarithmic argument\"}},\"getDecodedData(bytes)\":{\"details\":\"Decodes the parameters from the provided bytes.\",\"params\":{\"_data\":\"Bytes encoded auction parameters\"},\"returns\":{\"bucketSize\":\"         Time elapsed between each bucket\",\"initialPrice\":\"       Initial price of the auction\",\"isDecreasing\":\"       Flag for whether the price is decreasing or increasing\",\"maxPrice\":\"           Maximum price of the auction\",\"minPrice\":\"           Minimum price of the auction\",\"scalingFactor\":\"      Scaling factor for logarithmic expression\",\"timeCoefficient\":\"    Scaling factor for logarithmic argument\"}},\"getEncodedData(uint256,uint256,uint256,uint256,bool,uint256,uint256)\":{\"details\":\"Returns the encoded data for the price curve parameters\",\"params\":{\"_bucketSize\":\"Time elapsed between each bucket\",\"_initialPrice\":\"Initial price of the auction\",\"_isDecreasing\":\"Flag for whether the price is decreasing or increasing\",\"_maxPrice\":\"Maximum price of the auction\",\"_minPrice\":\"Minimum price of the auction\",\"_scalingFactor\":\"Scaling factor for logarithmic expression\",\"_timeCoefficient\":\"Scaling factor for logarithmic argument\"}},\"getPrice(address,address,uint256,uint256,uint256,bytes)\":{\"details\":\"Calculates and returns the logarithmic price.\",\"params\":{\"_priceAdapterConfigData\":\"Encoded bytes representing the logarithmic function parameters.\",\"_timeElapsed\":\"Time elapsed since the start of the auction.\"},\"returns\":{\"price\":\"                   The price calculated using the logarithmic function.\"}},\"isPriceAdapterConfigDataValid(bytes)\":{\"details\":\"Returns true if the price adapter is valid for the given parameters.\",\"params\":{\"_priceAdapterConfigData\":\"Encoded data for configuring the price adapter.\"},\"returns\":{\"isValid\":\"                 Boolean indicating if the adapter config data is valid.\"}}},\"title\":\"BoundedStepwiseLogarithmicPriceAdapter\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that increases or decreases logarithmically in steps over time, within a bounded range. The rate of change is decreasing. Price formula: price = initialPrice +/- scalingFactor * ln(timeCoefficient * timeBucket)\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/auction-pricing/BoundedStepwiseLogarithmicPriceAdapter.sol\":\"BoundedStepwiseLogarithmicPriceAdapter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/auction-pricing/BoundedStepwiseLogarithmicPriceAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport { FixedPointMathLib } from \\\"solady/src/utils/FixedPointMathLib.sol\\\";\\n\\n/**\\n * @title BoundedStepwiseLogarithmicPriceAdapter\\n * @author Index Coop\\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\\n * increases or decreases logarithmically in steps over time, within a bounded range.\\n * The rate of change is decreasing.\\n * Price formula: price = initialPrice +/- scalingFactor * ln(timeCoefficient * timeBucket)\\n */\\ncontract BoundedStepwiseLogarithmicPriceAdapter {\\n    using FixedPointMathLib for int256;\\n\\n    int256 private constant WAD = 1e18;                   // Equivalent to PreciseUnitMath.preciseUnit()\\n    int256 private constant MAX_LOG_ARG = 2 ** 254 - 1;   // To protect against overflow when adding WAD\\n\\n    /**\\n     * @dev Calculates and returns the logarithmic price.\\n     *\\n     * @param _timeElapsed              Time elapsed since the start of the auction.\\n     * @param _priceAdapterConfigData   Encoded bytes representing the logarithmic function parameters.\\n     *\\n     * @return price                    The price calculated using the logarithmic function.\\n     */\\n    function getPrice(\\n        address /* _setToken */,\\n        address /* _component */,\\n        uint256 /* _componentQuantity */,\\n        uint256 _timeElapsed,\\n        uint256 /* _duration */,\\n        bytes memory _priceAdapterConfigData\\n    )\\n        external\\n        pure\\n        returns (uint256 price)\\n    {\\n        (\\n            uint256 initialPrice,\\n            uint256 scalingFactor,\\n            uint256 timeCoefficient,\\n            uint256 bucketSize,\\n            bool isDecreasing,\\n            uint256 maxPrice,\\n            uint256 minPrice\\n        ) = getDecodedData(_priceAdapterConfigData);\\n\\n        require(\\n            areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice),\\n            \\\"BoundedStepwiseLogarithmicPriceAdapter: Invalid params\\\"\\n        );\\n\\n        uint256 timeBucket = _timeElapsed / bucketSize;\\n\\n        // Protect against logarithmic argument overflow\\n        if (timeBucket > uint256(type(int256).max) / timeCoefficient) {\\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\\n        }\\n        int256 lnArgument = int256(timeBucket * timeCoefficient);\\n\\n        // Protect against logarithmic overflow and increasing relative error\\n        if (lnArgument > MAX_LOG_ARG) {\\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\\n        }\\n        uint256 lnExpression = uint256(FixedPointMathLib.lnWad(lnArgument + WAD));\\n\\n        // Protect against priceChange overflow\\n        if (lnExpression > type(uint256).max / scalingFactor) {\\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\\n        }\\n        uint256 priceChange = FixedPointMathLib.mulWad(scalingFactor, lnExpression);\\n\\n        if (isDecreasing) {\\n            // Protect against price underflow\\n            if (priceChange > initialPrice) {\\n                return minPrice;\\n            }\\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\\n        } else {\\n            // Protect against price overflow\\n            if (priceChange > type(uint256).max - initialPrice) {\\n                return maxPrice;\\n            }\\n            return FixedPointMathLib.min(initialPrice + priceChange, maxPrice);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the price adapter is valid for the given parameters.\\n     *\\n     * @param _priceAdapterConfigData   Encoded data for configuring the price adapter.\\n     *\\n     * @return isValid                  Boolean indicating if the adapter config data is valid.\\n     */\\n    function isPriceAdapterConfigDataValid(\\n        bytes memory _priceAdapterConfigData\\n    )\\n        external\\n        pure\\n        returns (bool isValid)\\n    {\\n        (\\n            uint256 initialPrice,\\n            uint256 scalingFactor,\\n            uint256 timeCoefficient,\\n            uint256 bucketSize,\\n            ,\\n            uint256 maxPrice,\\n            uint256 minPrice\\n        ) = getDecodedData(_priceAdapterConfigData);\\n\\n        return areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice);\\n    }\\n\\n    /**\\n     * @dev Returns true if the price adapter parameters are valid.\\n     *\\n     * @param _initialPrice      Initial price of the auction\\n     * @param _scalingFactor     Scaling factor for logarithmic expression\\n     * @param _timeCoefficient   Scaling factor for logarithmic argument\\n     * @param _bucketSize        Time elapsed between each bucket\\n     * @param _maxPrice          Maximum price of the auction\\n     * @param _minPrice          Minimum price of the auction\\n     */\\n    function areParamsValid(\\n        uint256 _initialPrice,\\n        uint256 _scalingFactor,\\n        uint256 _timeCoefficient,\\n        uint256 _bucketSize,\\n        uint256 _maxPrice,\\n        uint256 _minPrice\\n    )\\n        public\\n        pure\\n        returns (bool)\\n    {\\n        return _initialPrice > 0\\n            && _scalingFactor > 0\\n            && _timeCoefficient > 0\\n            && _bucketSize > 0\\n            && _initialPrice <= _maxPrice\\n            && _initialPrice >= _minPrice;\\n    }\\n\\n    /**\\n     * @dev Returns the encoded data for the price curve parameters\\n     *\\n     * @param _initialPrice        Initial price of the auction\\n     * @param _scalingFactor       Scaling factor for logarithmic expression\\n     * @param _timeCoefficient     Scaling factor for logarithmic argument\\n     * @param _bucketSize          Time elapsed between each bucket\\n     * @param _isDecreasing        Flag for whether the price is decreasing or increasing\\n     * @param _maxPrice            Maximum price of the auction\\n     * @param _minPrice            Minimum price of the auction\\n     */\\n    function getEncodedData(\\n        uint256 _initialPrice,\\n        uint256 _scalingFactor,\\n        uint256 _timeCoefficient,\\n        uint256 _bucketSize,\\n        bool _isDecreasing,\\n        uint256 _maxPrice,\\n        uint256 _minPrice\\n    )\\n        external\\n        pure\\n        returns (bytes memory data)\\n    {\\n        return abi.encode(_initialPrice, _scalingFactor, _timeCoefficient, _bucketSize, _isDecreasing, _maxPrice, _minPrice);\\n    }\\n\\n    /**\\n     * @dev Decodes the parameters from the provided bytes.\\n     *\\n     * @param _data                Bytes encoded auction parameters\\n     * @return initialPrice        Initial price of the auction\\n     * @return scalingFactor       Scaling factor for logarithmic expression\\n     * @return timeCoefficient     Scaling factor for logarithmic argument\\n     * @return bucketSize          Time elapsed between each bucket\\n     * @return isDecreasing        Flag for whether the price is decreasing or increasing\\n     * @return maxPrice            Maximum price of the auction\\n     * @return minPrice            Minimum price of the auction\\n     */\\n    function getDecodedData(bytes memory _data)\\n        public\\n        pure\\n        returns (uint256 initialPrice, uint256 scalingFactor, uint256 timeCoefficient, uint256 bucketSize, bool isDecreasing, uint256 maxPrice, uint256 minPrice)\\n    {\\n        return abi.decode(_data, (uint256, uint256, uint256, uint256, bool, uint256, uint256));\\n    }\\n\\n    function _getBoundaryPrice(bool isDecreasing, uint256 maxPrice, uint256 minPrice) private pure returns (uint256) {\\n        return isDecreasing ? minPrice : maxPrice;\\n    }\\n}\\n\",\"keccak256\":\"0xc28f55e2956265e312289fcd0767049c0f4e27c32c12c1a84f01465dc6dd268e\",\"license\":\"Apache-2.0\"},\"solady/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error FactorialOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error DivWadFailed();\\n\\n    /// @dev The multiply-divide operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error MulDivFailed();\\n\\n    /// @dev The division failed, as the denominator is zero.\\n    error DivFailed();\\n\\n    /// @dev The full precision multiply-divide operation failed, either due\\n    /// to the result being larger than 256 bits, or a division by a zero.\\n    error FullMulDivFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /// @dev The output is undefined, as the input is zero.\\n    error Log2Undefined();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `x` to the power of `y`.\\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Using `ln(x)` means `x` must be greater than 0.\\n        return expWad((lnWad(x) * y) / int256(WAD));\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n                // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    // Store the function selector of `ExpOverflow()`.\\n                    mstore(0x00, 0xa37bfec9)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256(\\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\\n            );\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                if iszero(sgt(x, 0)) {\\n                    // Store the function selector of `LnWadUndefined()`.\\n                    mstore(0x00, 0x1615e638)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Compute k = log2(x) - 96.\\n            int256 k;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let v := x\\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, v))\\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, v))))\\n                k := or(k, shl(5, lt(0xffffffff, shr(k, v))))\\n\\n                // For the remaining 32 bits, use a De Bruijn lookup.\\n                // See: https://graphics.stanford.edu/~seander/bithacks.html\\n                v := shr(k, v)\\n                v := or(v, shr(1, v))\\n                v := or(v, shr(2, v))\\n                v := or(v, shr(4, v))\\n                v := or(v, shr(8, v))\\n                v := or(v, shr(16, v))\\n\\n                // forgefmt: disable-next-item\\n                k := sub(or(k, byte(shr(251, mul(v, shl(224, 0x07c4acdd))),\\n                    0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)), 96)\\n            }\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  GENERAL NUMBER UTILITIES                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Calculates `floor(a * b / d)` with full precision.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/21/muldiv\\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for {} 1 {} {\\n                // 512-bit multiply `[prod1 prod0] = x * y`.\\n                // Compute the product mod `2**256` and mod `2**256 - 1`\\n                // then use the Chinese Remainder Theorem to reconstruct\\n                // the 512 bit result. The result is stored in two 256\\n                // variables such that `product = prod1 * 2**256 + prod0`.\\n\\n                // Least significant 256 bits of the product.\\n                let prod0 := mul(x, y)\\n                let mm := mulmod(x, y, not(0))\\n                // Most significant 256 bits of the product.\\n                let prod1 := sub(mm, add(prod0, lt(mm, prod0)))\\n\\n                // Handle non-overflow cases, 256 by 256 division.\\n                if iszero(prod1) {\\n                    if iszero(d) {\\n                        // Store the function selector of `FullMulDivFailed()`.\\n                        mstore(0x00, 0xae47f702)\\n                        // Revert with (offset, size).\\n                        revert(0x1c, 0x04)\\n                    }\\n                    result := div(prod0, d)\\n                    break       \\n                }\\n\\n                // Make sure the result is less than `2**256`.\\n                // Also prevents `d == 0`.\\n                if iszero(gt(d, prod1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n\\n                ///////////////////////////////////////////////\\n                // 512 by 256 division.\\n                ///////////////////////////////////////////////\\n\\n                // Make division exact by subtracting the remainder from `[prod1 prod0]`.\\n                // Compute remainder using mulmod.\\n                let remainder := mulmod(x, y, d)\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n                // Factor powers of two out of `d`.\\n                // Compute largest power of two divisor of `d`.\\n                // Always greater or equal to 1.\\n                let twos := and(d, sub(0, d))\\n                // Divide d by power of two.\\n                d := div(d, twos)\\n                // Divide [prod1 prod0] by the factors of two.\\n                prod0 := div(prod0, twos)\\n                // Shift in bits from `prod1` into `prod0`. For this we need\\n                // to flip `twos` such that it is `2**256 / twos`.\\n                // If `twos` is zero, then it becomes one.\\n                prod0 := or(prod0, mul(prod1, add(div(sub(0, twos), twos), 1)))\\n                // Invert `d mod 2**256`\\n                // Now that `d` is an odd number, it has an inverse\\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\\n                // Compute the inverse by starting with a seed that is correct\\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\\n                let inv := xor(mul(3, d), 2)\\n                // Now use Newton-Raphson iteration to improve the precision.\\n                // Thanks to Hensel's lifting lemma, this also works in modular\\n                // arithmetic, doubling the correct bits in each step.\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\\n                result := mul(prod0, mul(inv, sub(2, mul(d, inv)))) // inverse mod 2**256\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Uniswap-v3-core under MIT license:\\n    /// https://github.com/Uniswap/v3-core/blob/contracts/libraries/FullMath.sol\\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        result = fullMulDiv(x, y, d);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mulmod(x, y, d) {\\n                if iszero(add(result, 1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n                result := add(result, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `floor(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), d)\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x / d)`.\\n    /// Reverts if `d` is zero.\\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(d) {\\n                // Store the function selector of `DivFailed()`.\\n                mstore(0x00, 0x65244e4e)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`.\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // Let `y = x / 2**r`.\\n            // We check `y >= 2**(k + 8)` but shift right by `k` bits\\n            // each branch to ensure that if `x >= 256`, then `y >= 256`.\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\\n            z := shl(shr(1, r), z)\\n\\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\\n\\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\\n\\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\\n\\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\\n            // Then we can estimate `sqrt(y)` using\\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\\n\\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If `x+1` is a perfect square, the Babylonian method cycles between\\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    /// @dev Returns the cube root of `x`.\\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n\\n            z := shl(add(div(r, 3), lt(0xf, shr(r, x))), 0xff)\\n            z := div(z, byte(mod(r, 3), shl(232, 0x7f624b)))\\n\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n\\n            z := sub(z, lt(div(x, mul(z, z)), z))\\n        }\\n    }\\n\\n    /// @dev Returns the factorial of `x`.\\n    function factorial(uint256 x) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, 58)) {\\n                // Store the function selector of `FactorialOverflow()`.\\n                mstore(0x00, 0xaba0f2a2)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            for { result := 1 } x {} {\\n                result := mul(result, x)\\n                x := sub(x, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`.\\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(x) {\\n                // Store the function selector of `Log2Undefined()`.\\n                mstore(0x00, 0x5be3aa5c)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // See: https://graphics.stanford.edu/~seander/bithacks.html\\n            x := shr(r, x)\\n            x := or(x, shr(1, x))\\n            x := or(x, shr(2, x))\\n            x := or(x, shr(4, x))\\n            x := or(x, shr(8, x))\\n            x := or(x, shr(16, x))\\n\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`, rounded up.\\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\\n        unchecked {\\n            uint256 isNotPo2;\\n            assembly {\\n                isNotPo2 := iszero(iszero(and(x, sub(x, 1))))\\n            }\\n            return log2(x) + isNotPo2;\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = (x & y) + ((x ^ y) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = (x >> 1) + (y >> 1) + (((x & 1) + (y & 1)) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the absolute value of `x`.\\n    function abs(int256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := sub(0, shr(255, x))\\n            z := xor(mask, add(mask, x))\\n        }\\n    }\\n\\n    /// @dev Returns the absolute distance between `x` and `y`.\\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let a := sub(y, x)\\n            z := xor(a, mul(xor(a, sub(x, y)), sgt(x, y)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns greatest common divisor of `x` and `y`.\\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for { z := x } y {} {\\n                let t := y\\n                y := mod(z, y)\\n                z := t\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RAW NUMBER OPERATIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := smod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := addmod(x, y, d)\\n        }\\n    }\\n\\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mulmod(x, y, d)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd665d762c3c415f9227b326d0e6c814f0366eb6c5dd3283de5fcdc028e6a07f5\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610a45806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c8063079f6bf41461005c578063104b9b6414610084578063777f4126146100a5578063a45f8c07146100b8578063d3516db614610120575b600080fd5b61006f61006a366004610740565b61016a565b60405190151581526020015b60405180910390f35b610097610092366004610791565b6101a5565b60405190815260200161007b565b61006f6100b336600461080b565b6103ab565b6101136100c636600461085f565b6040805160208101989098528781019690965260608701949094526080860192909252151560a085015260c084015260e08084019190915281518084039091018152610100909201905290565b60405161007b91906108be565b61013361012e366004610740565b6103f7565b6040805197885260208801969096529486019390935260608501919091521515608084015260a083015260c082015260e00161007b565b600080600080600080600061017e886103f7565b965096505095509550955095506101998686868686866103ab565b98975050505050505050565b6000806000806000806000806101ba896103f7565b96509650965096509650965096506101d68787878786866103ab565b6102455760405162461bcd60e51b815260206004820152603660248201527f426f756e64656453746570776973654c6f6761726974686d69635072696365416044820152756461707465723a20496e76616c696420706172616d7360501b606482015260840160405180910390fd5b6000610251858d610922565b9050610264866001600160ff1b03610922565b8111156102855761027684848461042d565b985050505050505050506103a1565b60006102918783610944565b90506001600160fe1b038113156102bd576102ad85858561042d565b99505050505050505050506103a1565b60006102d96102d4670de0b6b3a764000084610961565b610444565b90506102e789600019610922565b81111561030a576102f986868661042d565b9a50505050505050505050506103a1565b60006103168a8361066f565b90508615610363578a81111561033957849b5050505050505050505050506103a1565b610351610346828d610989565b868110818818021890565b9b5050505050505050505050506103a1565b61036f8b600019610989565b81111561038957859b5050505050505050505050506103a1565b610351610396828d61099c565b878111818918021890565b9695505050505050565b600080871180156103bc5750600086115b80156103c85750600085115b80156103d45750600084115b80156103e05750828711155b80156103ec5750818710155b979650505050505050565b60008060008060008060008780602001905181019061041691906109af565b959e949d50929b5090995097509550909350915050565b60008361043a578261043c565b815b949350505050565b600080821361045b57631615e6386000526004601cfd5b5060607e09010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f6fffffffffffffffffffffffffffffffff831160071b83811c67ffffffffffffffff1060061b1783811c63ffffffff1060051b1783811c600181901c17600281901c17600481901c17600881901c17601081901c176307c4acdd60e01b0260fb1c9190911a17609f81810383019390931b90921c6c465772b2bbbb5f824b15207a3081018102821d6d0388eaa27412d5aca026815d636e018102821d6d0df99ac502031bf953eff472fdcc018102821d6d13cdffb29d51d99322bdff5f2211018102821d6d0a0f742023def783a307a986912e018102821d6d01920d8043ca89b5239253284e42018102821d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7882018202831d6d0139601a2efabe717e604cbb4894018202831d6d02247f7a7b6594320649aa03aba1018202831d6c8c3f38e95a6b1ff2ab1c3b343619018202831d6d02384773bdf1ac5676facced60901901820290921d6cb9a025d814b29c212b8b1a07cd190102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a550602605f19919091017d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d90565b60008160001904831182021561068d5763bac65e5b6000526004601cfd5b50670de0b6b3a764000091020490565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126106c457600080fd5b813567ffffffffffffffff808211156106df576106df61069d565b604051601f8301601f19908116603f011681019082821181831017156107075761070761069d565b8160405283815286602085880101111561072057600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561075257600080fd5b813567ffffffffffffffff81111561076957600080fd5b61043c848285016106b3565b80356001600160a01b038116811461078c57600080fd5b919050565b60008060008060008060c087890312156107aa57600080fd5b6107b387610775565b95506107c160208801610775565b945060408701359350606087013592506080870135915060a087013567ffffffffffffffff8111156107f257600080fd5b6107fe89828a016106b3565b9150509295509295509295565b60008060008060008060c0878903121561082457600080fd5b505084359660208601359650604086013595606081013595506080810135945060a0013592509050565b801515811461085c57600080fd5b50565b600080600080600080600060e0888a03121561087a57600080fd5b8735965060208801359550604088013594506060880135935060808801356108a18161084e565b9699959850939692959460a0840135945060c09093013592915050565b600060208083528351808285015260005b818110156108eb578581018301518582016040015282016108cf565b506000604082860101526040601f19601f8301168501019250505092915050565b634e487b7160e01b600052601160045260246000fd5b60008261093f57634e487b7160e01b600052601260045260246000fd5b500490565b808202811582820484141761095b5761095b61090c565b92915050565b80820182811260008312801582168215821617156109815761098161090c565b505092915050565b8181038181111561095b5761095b61090c565b8082018082111561095b5761095b61090c565b600080600080600080600060e0888a0312156109ca57600080fd5b8751965060208801519550604088015194506060880151935060808801516109f18161084e565b8093505060a0880151915060c088015190509295989194975092955056fea26469706673582212208f3a49f75b1a32470e8043ff97167e45e82ec3a5b1ab9817d8bb44656792518d64736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c8063079f6bf41461005c578063104b9b6414610084578063777f4126146100a5578063a45f8c07146100b8578063d3516db614610120575b600080fd5b61006f61006a366004610740565b61016a565b60405190151581526020015b60405180910390f35b610097610092366004610791565b6101a5565b60405190815260200161007b565b61006f6100b336600461080b565b6103ab565b6101136100c636600461085f565b6040805160208101989098528781019690965260608701949094526080860192909252151560a085015260c084015260e08084019190915281518084039091018152610100909201905290565b60405161007b91906108be565b61013361012e366004610740565b6103f7565b6040805197885260208801969096529486019390935260608501919091521515608084015260a083015260c082015260e00161007b565b600080600080600080600061017e886103f7565b965096505095509550955095506101998686868686866103ab565b98975050505050505050565b6000806000806000806000806101ba896103f7565b96509650965096509650965096506101d68787878786866103ab565b6102455760405162461bcd60e51b815260206004820152603660248201527f426f756e64656453746570776973654c6f6761726974686d69635072696365416044820152756461707465723a20496e76616c696420706172616d7360501b606482015260840160405180910390fd5b6000610251858d610922565b9050610264866001600160ff1b03610922565b8111156102855761027684848461042d565b985050505050505050506103a1565b60006102918783610944565b90506001600160fe1b038113156102bd576102ad85858561042d565b99505050505050505050506103a1565b60006102d96102d4670de0b6b3a764000084610961565b610444565b90506102e789600019610922565b81111561030a576102f986868661042d565b9a50505050505050505050506103a1565b60006103168a8361066f565b90508615610363578a81111561033957849b5050505050505050505050506103a1565b610351610346828d610989565b868110818818021890565b9b5050505050505050505050506103a1565b61036f8b600019610989565b81111561038957859b5050505050505050505050506103a1565b610351610396828d61099c565b878111818918021890565b9695505050505050565b600080871180156103bc5750600086115b80156103c85750600085115b80156103d45750600084115b80156103e05750828711155b80156103ec5750818710155b979650505050505050565b60008060008060008060008780602001905181019061041691906109af565b959e949d50929b5090995097509550909350915050565b60008361043a578261043c565b815b949350505050565b600080821361045b57631615e6386000526004601cfd5b5060607e09010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f6fffffffffffffffffffffffffffffffff831160071b83811c67ffffffffffffffff1060061b1783811c63ffffffff1060051b1783811c600181901c17600281901c17600481901c17600881901c17601081901c176307c4acdd60e01b0260fb1c9190911a17609f81810383019390931b90921c6c465772b2bbbb5f824b15207a3081018102821d6d0388eaa27412d5aca026815d636e018102821d6d0df99ac502031bf953eff472fdcc018102821d6d13cdffb29d51d99322bdff5f2211018102821d6d0a0f742023def783a307a986912e018102821d6d01920d8043ca89b5239253284e42018102821d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7882018202831d6d0139601a2efabe717e604cbb4894018202831d6d02247f7a7b6594320649aa03aba1018202831d6c8c3f38e95a6b1ff2ab1c3b343619018202831d6d02384773bdf1ac5676facced60901901820290921d6cb9a025d814b29c212b8b1a07cd190102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a550602605f19919091017d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d90565b60008160001904831182021561068d5763bac65e5b6000526004601cfd5b50670de0b6b3a764000091020490565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126106c457600080fd5b813567ffffffffffffffff808211156106df576106df61069d565b604051601f8301601f19908116603f011681019082821181831017156107075761070761069d565b8160405283815286602085880101111561072057600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561075257600080fd5b813567ffffffffffffffff81111561076957600080fd5b61043c848285016106b3565b80356001600160a01b038116811461078c57600080fd5b919050565b60008060008060008060c087890312156107aa57600080fd5b6107b387610775565b95506107c160208801610775565b945060408701359350606087013592506080870135915060a087013567ffffffffffffffff8111156107f257600080fd5b6107fe89828a016106b3565b9150509295509295509295565b60008060008060008060c0878903121561082457600080fd5b505084359660208601359650604086013595606081013595506080810135945060a0013592509050565b801515811461085c57600080fd5b50565b600080600080600080600060e0888a03121561087a57600080fd5b8735965060208801359550604088013594506060880135935060808801356108a18161084e565b9699959850939692959460a0840135945060c09093013592915050565b600060208083528351808285015260005b818110156108eb578581018301518582016040015282016108cf565b506000604082860101526040601f19601f8301168501019250505092915050565b634e487b7160e01b600052601160045260246000fd5b60008261093f57634e487b7160e01b600052601260045260246000fd5b500490565b808202811582820484141761095b5761095b61090c565b92915050565b80820182811260008312801582168215821617156109815761098161090c565b505092915050565b8181038181111561095b5761095b61090c565b8082018082111561095b5761095b61090c565b600080600080600080600060e0888a0312156109ca57600080fd5b8751965060208801519550604088015194506060880151935060808801516109f18161084e565b8093505060a0880151915060c088015190509295989194975092955056fea26469706673582212208f3a49f75b1a32470e8043ff97167e45e82ec3a5b1ab9817d8bb44656792518d64736f6c63430008110033",
  "devdoc": {
    "author": "Index Coop",
    "kind": "dev",
    "methods": {
      "areParamsValid(uint256,uint256,uint256,uint256,uint256,uint256)": {
        "details": "Returns true if the price adapter parameters are valid.",
        "params": {
          "_bucketSize": "Time elapsed between each bucket",
          "_initialPrice": "Initial price of the auction",
          "_maxPrice": "Maximum price of the auction",
          "_minPrice": "Minimum price of the auction",
          "_scalingFactor": "Scaling factor for logarithmic expression",
          "_timeCoefficient": "Scaling factor for logarithmic argument"
        }
      },
      "getDecodedData(bytes)": {
        "details": "Decodes the parameters from the provided bytes.",
        "params": {
          "_data": "Bytes encoded auction parameters"
        },
        "returns": {
          "bucketSize": "         Time elapsed between each bucket",
          "initialPrice": "       Initial price of the auction",
          "isDecreasing": "       Flag for whether the price is decreasing or increasing",
          "maxPrice": "           Maximum price of the auction",
          "minPrice": "           Minimum price of the auction",
          "scalingFactor": "      Scaling factor for logarithmic expression",
          "timeCoefficient": "    Scaling factor for logarithmic argument"
        }
      },
      "getEncodedData(uint256,uint256,uint256,uint256,bool,uint256,uint256)": {
        "details": "Returns the encoded data for the price curve parameters",
        "params": {
          "_bucketSize": "Time elapsed between each bucket",
          "_initialPrice": "Initial price of the auction",
          "_isDecreasing": "Flag for whether the price is decreasing or increasing",
          "_maxPrice": "Maximum price of the auction",
          "_minPrice": "Minimum price of the auction",
          "_scalingFactor": "Scaling factor for logarithmic expression",
          "_timeCoefficient": "Scaling factor for logarithmic argument"
        }
      },
      "getPrice(address,address,uint256,uint256,uint256,bytes)": {
        "details": "Calculates and returns the logarithmic price.",
        "params": {
          "_priceAdapterConfigData": "Encoded bytes representing the logarithmic function parameters.",
          "_timeElapsed": "Time elapsed since the start of the auction."
        },
        "returns": {
          "price": "                   The price calculated using the logarithmic function."
        }
      },
      "isPriceAdapterConfigDataValid(bytes)": {
        "details": "Returns true if the price adapter is valid for the given parameters.",
        "params": {
          "_priceAdapterConfigData": "Encoded data for configuring the price adapter."
        },
        "returns": {
          "isValid": "                 Boolean indicating if the adapter config data is valid."
        }
      }
    },
    "title": "BoundedStepwiseLogarithmicPriceAdapter",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that increases or decreases logarithmically in steps over time, within a bounded range. The rate of change is decreasing. Price formula: price = initialPrice +/- scalingFactor * ln(timeCoefficient * timeBucket)",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}