{
  "language": "Solidity",
  "sources": {
    "contracts/auction-pricing/BoundedStepwiseExponentialPriceAdapter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title BoundedStepwiseExponentialPriceAdapter\n * @author Index Coop\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\n * increases or decreases exponentially in steps over time, within a bounded range.\n * The rate of change is increasing.\n * Price formula: price = initialPrice +/- scalingFactor * e ^ (timeCoefficient * timeBucket)\n */\ncontract BoundedStepwiseExponentialPriceAdapter {\n    using FixedPointMathLib for int256;\n\n    uint256 constant WAD = 1e18;            // Equivalent to PreciseUnitMath.preciseUnit()\n    int256 constant MAX_EXP_ARG = 100e18;   // To protect against overflow and increasing relative error\n\n    /**\n     * @dev Calculates and returns the exponential price.\n     *\n     * @param _timeElapsed              Time elapsed since the start of the auction.\n     * @param _priceAdapterConfigData   Encoded bytes representing the exponential function parameters.\n     *\n     * @return price                    The price calculated using the exponential function.\n     */\n    function getPrice(\n        address /* _setToken */,\n        address /* _component */,\n        uint256 /* _componentQuantity */,\n        uint256 _timeElapsed,\n        uint256 /* _duration */,\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (uint256 price)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            bool isDecreasing,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        require(\n            areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice),\n            \"BoundedStepwiseExponentialPriceAdapter: Invalid params\"\n        );\n\n        uint256 timeBucket = _timeElapsed / bucketSize;\n\n        // Protect against exponential argument overflow\n        if (timeBucket > uint256(type(int256).max) / timeCoefficient) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        int256 expArgument = int256(timeCoefficient * timeBucket);\n\n        // Protect against exponential overflow and increasing relative error\n        if (expArgument > MAX_EXP_ARG) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\n        // Protect against priceChange overflow\n        if (scalingFactor > type(uint256).max / expExpression) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 priceChange = FixedPointMathLib.mulWad(scalingFactor, expExpression - WAD);\n\n        if (isDecreasing) {\n            // Protect against price underflow\n            if (priceChange > initialPrice) {\n                return minPrice;\n            }\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\n        } else {\n            // Protect against price overflow\n            if (priceChange > type(uint256).max - initialPrice) {\n                return maxPrice;\n            }\n            return FixedPointMathLib.min(initialPrice + priceChange, maxPrice);\n        }\n    }\n\n    /**\n     * @dev Returns true if the price adapter is valid for the given parameters.\n     *\n     * @param _priceAdapterConfigData   Encoded data for configuring the price adapter.\n     *\n     * @return isValid                  Boolean indicating if the adapter config data is valid.\n     */\n    function isPriceAdapterConfigDataValid(\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (bool isValid)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            ,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        return areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice);\n    }\n\n    /**\n     * @dev Returns true if the price adapter parameters are valid.\n     *\n     * @param _initialPrice      Initial price of the auction\n     * @param _scalingFactor     Scaling factor for exponential expression\n     * @param _timeCoefficient   Scaling factor for exponential argument\n     * @param _bucketSize        Time elapsed between each bucket\n     * @param _maxPrice          Maximum price of the auction\n     * @param _minPrice          Minimum price of the auction\n     */\n    function areParamsValid(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return _initialPrice > 0\n            && _scalingFactor > 0\n            && _timeCoefficient > 0\n            && _bucketSize > 0\n            && _initialPrice <= _maxPrice\n            && _initialPrice >= _minPrice;\n    }\n\n    /**\n     * @dev Returns the encoded data for the price curve parameters\n     *\n     * @param _initialPrice        Initial price of the auction\n     * @param _scalingFactor       Scaling factor for exponential expression\n     * @param _timeCoefficient     Scaling factor for exponential argument\n     * @param _bucketSize          Time elapsed between each bucket\n     * @param _isDecreasing        Flag for whether the price is decreasing or increasing\n     * @param _maxPrice            Maximum price of the auction\n     * @param _minPrice            Minimum price of the auction\n     */\n    function getEncodedData(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        bool _isDecreasing,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        external\n        pure\n        returns (bytes memory data)\n    {\n        return abi.encode(_initialPrice, _scalingFactor, _timeCoefficient, _bucketSize, _isDecreasing, _maxPrice, _minPrice);\n    }\n\n    /**\n     * @dev Decodes the parameters from the provided bytes.\n     *\n     * @param _data                Bytes encoded auction parameters\n     * @return initialPrice        Initial price of the auction\n     * @return scalingFactor       Scaling factor for exponential expression\n     * @return timeCoefficient     Scaling factor for exponential argument\n     * @return bucketSize          Time elapsed between each bucket\n     * @return isDecreasing        Flag for whether the price is decreasing or increasing\n     * @return maxPrice            Maximum price of the auction\n     * @return minPrice            Minimum price of the auction\n     */\n    function getDecodedData(bytes memory _data)\n        public\n        pure\n        returns (uint256 initialPrice, uint256 scalingFactor, uint256 timeCoefficient, uint256 bucketSize, bool isDecreasing, uint256 maxPrice, uint256 minPrice)\n    {\n        return abi.decode(_data, (uint256, uint256, uint256, uint256, bool, uint256, uint256));\n    }\n\n    function _getBoundaryPrice(bool isDecreasing, uint256 maxPrice, uint256 minPrice) private pure returns (uint256) {\n        return isDecreasing ? minPrice : maxPrice;\n    }\n}"
    },
    "contracts/auction-pricing/BoundedStepwiseLinearPriceAdapter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title BoundedStepwiseLinearPriceAdapter\n * @author Index Coop\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\n * increases or decreases linearly in steps over time, within a bounded range.\n * The rate of change is constant.\n * Price formula: price = initialPrice +/- slope * timeBucket\n */\ncontract BoundedStepwiseLinearPriceAdapter {\n\n    /**\n     * @dev Calculates and returns the linear price.\n     *\n     * @param _timeElapsed              Time elapsed since the start of the auction.\n     * @param _priceAdapterConfigData   Encoded bytes representing the linear function parameters.\n     *\n     * @return price                    The price calculated using the linear function.\n     */\n    function getPrice(\n        address /* _setToken */,\n        address /* _component */,\n        uint256 /* _componentQuantity */,\n        uint256 _timeElapsed,\n        uint256 /* _duration */,\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (uint256 price)\n    {\n        (\n            uint256 initialPrice,\n            uint256 slope,\n            uint256 bucketSize,\n            bool isDecreasing,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        require(\n            areParamsValid(initialPrice, slope, bucketSize, maxPrice, minPrice),\n            \"BoundedStepwiseLinearPriceAdapter: Invalid params\"\n        );\n\n        uint256 bucket = _timeElapsed / bucketSize;\n\n        // Protect against priceChange overflow\n        if (bucket > type(uint256).max / slope) {\n            return isDecreasing ? minPrice : maxPrice;\n        }\n\n        uint256 priceChange = bucket * slope;\n\n        if (isDecreasing) {\n            // Protect against price underflow\n            if (priceChange > initialPrice) {\n                return minPrice;\n            }\n            return FixedPointMathLib.max(initialPrice - priceChange, minPrice);\n        } else {\n            // Protect against price overflow\n            if (priceChange > type(uint256).max - initialPrice) {\n                return maxPrice;\n            }\n            return FixedPointMathLib.min(initialPrice + priceChange, maxPrice);\n        }\n    }\n\n    /**\n     * @dev Returns true if the price adapter is valid for the given parameters.\n     *\n     * @param _priceAdapterConfigData   Encoded data for configuring the price adapter.\n     *\n     * @return isValid                  Boolean indicating if the adapter config data is valid.\n     */\n    function isPriceAdapterConfigDataValid(\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (bool isValid)\n    {\n        (\n            uint256 initialPrice,\n            uint256 slope,\n            uint256 bucketSize,\n            ,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        return areParamsValid(initialPrice, slope, bucketSize, maxPrice, minPrice);\n    }\n\n    /**\n     * @dev Returns true if the price adapter parameters are valid.\n     *\n     * @param _initialPrice      Initial price of the auction\n     * @param _bucketSize        Time elapsed between each bucket\n     * @param _maxPrice          Maximum price of the auction\n     * @param _minPrice          Minimum price of the auction\n     */\n    function areParamsValid(\n        uint256 _initialPrice,\n        uint256 _slope,\n        uint256 _bucketSize,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return _initialPrice > 0\n            && _slope > 0\n            && _bucketSize > 0\n            && _initialPrice <= _maxPrice\n            && _initialPrice >= _minPrice;\n    }\n\n    /**\n     * @dev Returns the encoded data for the price curve parameters\n     *\n     * @param _initialPrice      Initial price of the auction\n     * @param _slope             Slope of the linear price change\n     * @param _bucketSize        Time elapsed between each bucket\n     * @param _isDecreasing      Flag for whether the price is decreasing or increasing\n     * @param _maxPrice          Maximum price of the auction\n     * @param _minPrice          Minimum price of the auction\n     */\n    function getEncodedData(\n        uint256 _initialPrice,\n        uint256 _slope,\n        uint256 _bucketSize,\n        bool _isDecreasing,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        external\n        pure\n        returns (bytes memory data)\n    {\n        return abi.encode(_initialPrice, _slope, _bucketSize, _isDecreasing, _maxPrice, _minPrice);\n    }\n\n    /**\n     * @dev Decodes the parameters from the provided bytes.\n     *\n     * @param _data           Bytes encoded auction parameters\n     * @return initialPrice   Initial price of the auction\n     * @return slope          Slope of the linear price change\n     * @return bucketSize     Time elapsed between each bucket\n     * @return isDecreasing   Flag for whether the price is decreasing or increasing\n     * @return maxPrice       Maximum price of the auction\n     * @return minPrice       Minimum price of the auction\n     */\n    function getDecodedData(bytes memory _data)\n        public\n        pure\n        returns (uint256 initialPrice, uint256 slope, uint256 bucketSize, bool isDecreasing, uint256 maxPrice, uint256 minPrice)\n    {\n        return abi.decode(_data, (uint256, uint256, uint256, bool, uint256, uint256));\n    }\n}\n"
    },
    "contracts/auction-pricing/BoundedStepwiseLogarithmicPriceAdapter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title BoundedStepwiseLogarithmicPriceAdapter\n * @author Index Coop\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\n * increases or decreases logarithmically in steps over time, within a bounded range.\n * The rate of change is decreasing.\n * Price formula: price = initialPrice +/- scalingFactor * ln(timeCoefficient * timeBucket)\n */\ncontract BoundedStepwiseLogarithmicPriceAdapter {\n    using FixedPointMathLib for int256;\n\n    int256 private constant WAD = 1e18;                   // Equivalent to PreciseUnitMath.preciseUnit()\n    int256 private constant MAX_LOG_ARG = 2 ** 254 - 1;   // To protect against overflow when adding WAD\n\n    /**\n     * @dev Calculates and returns the logarithmic price.\n     *\n     * @param _timeElapsed              Time elapsed since the start of the auction.\n     * @param _priceAdapterConfigData   Encoded bytes representing the logarithmic function parameters.\n     *\n     * @return price                    The price calculated using the logarithmic function.\n     */\n    function getPrice(\n        address /* _setToken */,\n        address /* _component */,\n        uint256 /* _componentQuantity */,\n        uint256 _timeElapsed,\n        uint256 /* _duration */,\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (uint256 price)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            bool isDecreasing,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        require(\n            areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice),\n            \"BoundedStepwiseLogarithmicPriceAdapter: Invalid params\"\n        );\n\n        uint256 timeBucket = _timeElapsed / bucketSize;\n\n        // Protect against logarithmic argument overflow\n        if (timeBucket > uint256(type(int256).max) / timeCoefficient) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        int256 lnArgument = int256(timeBucket * timeCoefficient);\n\n        // Protect against logarithmic overflow and increasing relative error\n        if (lnArgument > MAX_LOG_ARG) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 lnExpression = uint256(FixedPointMathLib.lnWad(lnArgument + WAD));\n\n        // Protect against priceChange overflow\n        if (lnExpression > type(uint256).max / scalingFactor) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 priceChange = FixedPointMathLib.mulWad(scalingFactor, lnExpression);\n\n        if (isDecreasing) {\n            // Protect against price underflow\n            if (priceChange > initialPrice) {\n                return minPrice;\n            }\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\n        } else {\n            // Protect against price overflow\n            if (priceChange > type(uint256).max - initialPrice) {\n                return maxPrice;\n            }\n            return FixedPointMathLib.min(initialPrice + priceChange, maxPrice);\n        }\n    }\n\n    /**\n     * @dev Returns true if the price adapter is valid for the given parameters.\n     *\n     * @param _priceAdapterConfigData   Encoded data for configuring the price adapter.\n     *\n     * @return isValid                  Boolean indicating if the adapter config data is valid.\n     */\n    function isPriceAdapterConfigDataValid(\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (bool isValid)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            ,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        return areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice);\n    }\n\n    /**\n     * @dev Returns true if the price adapter parameters are valid.\n     *\n     * @param _initialPrice      Initial price of the auction\n     * @param _scalingFactor     Scaling factor for logarithmic expression\n     * @param _timeCoefficient   Scaling factor for logarithmic argument\n     * @param _bucketSize        Time elapsed between each bucket\n     * @param _maxPrice          Maximum price of the auction\n     * @param _minPrice          Minimum price of the auction\n     */\n    function areParamsValid(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return _initialPrice > 0\n            && _scalingFactor > 0\n            && _timeCoefficient > 0\n            && _bucketSize > 0\n            && _initialPrice <= _maxPrice\n            && _initialPrice >= _minPrice;\n    }\n\n    /**\n     * @dev Returns the encoded data for the price curve parameters\n     *\n     * @param _initialPrice        Initial price of the auction\n     * @param _scalingFactor       Scaling factor for logarithmic expression\n     * @param _timeCoefficient     Scaling factor for logarithmic argument\n     * @param _bucketSize          Time elapsed between each bucket\n     * @param _isDecreasing        Flag for whether the price is decreasing or increasing\n     * @param _maxPrice            Maximum price of the auction\n     * @param _minPrice            Minimum price of the auction\n     */\n    function getEncodedData(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        bool _isDecreasing,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        external\n        pure\n        returns (bytes memory data)\n    {\n        return abi.encode(_initialPrice, _scalingFactor, _timeCoefficient, _bucketSize, _isDecreasing, _maxPrice, _minPrice);\n    }\n\n    /**\n     * @dev Decodes the parameters from the provided bytes.\n     *\n     * @param _data                Bytes encoded auction parameters\n     * @return initialPrice        Initial price of the auction\n     * @return scalingFactor       Scaling factor for logarithmic expression\n     * @return timeCoefficient     Scaling factor for logarithmic argument\n     * @return bucketSize          Time elapsed between each bucket\n     * @return isDecreasing        Flag for whether the price is decreasing or increasing\n     * @return maxPrice            Maximum price of the auction\n     * @return minPrice            Minimum price of the auction\n     */\n    function getDecodedData(bytes memory _data)\n        public\n        pure\n        returns (uint256 initialPrice, uint256 scalingFactor, uint256 timeCoefficient, uint256 bucketSize, bool isDecreasing, uint256 maxPrice, uint256 minPrice)\n    {\n        return abi.decode(_data, (uint256, uint256, uint256, uint256, bool, uint256, uint256));\n    }\n\n    function _getBoundaryPrice(bool isDecreasing, uint256 maxPrice, uint256 minPrice) private pure returns (uint256) {\n        return isDecreasing ? minPrice : maxPrice;\n    }\n}\n"
    },
    "contracts/auction-pricing/ConstantPriceAdapter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @title ConstantPriceAdapter\n * @author Index Coop\n * @notice Price adapter contract for AuctionRebalanceModuleV1 that returns a constant price.\n * The rate of change is zero.\n * Price formula: price = initialPrice\n */\ncontract ConstantPriceAdapter {\n    /**\n     * @dev Calculates and returns the constant price.\n     *\n     * @param _priceAdapterConfigData   Encoded bytes representing the constant price.\n     *\n     * @return price                    The constant price decoded from _priceAdapterConfigData.\n     */\n    function getPrice(\n        address /* _setToken */,\n        address /* _component */,\n        uint256 /* _componentQuantity */,\n        uint256 /* _timeElapsed */,\n        uint256 /* _duration */,\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (uint256 price)\n    {\n        price = getDecodedData(_priceAdapterConfigData);\n        require(price > 0, \"ConstantPriceAdapter: Price must be greater than 0\");\n    }\n\n    /**\n     * @notice Returns true if the price adapter configuration data is valid.\n     *\n     * @param _priceAdapterConfigData   Encoded bytes representing the constant price.\n     *\n     * @return isValid                  True if the constant price is greater than 0, False otherwise.\n     */\n    function isPriceAdapterConfigDataValid(\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (bool isValid)\n    {\n        uint256 price = getDecodedData(_priceAdapterConfigData);\n        isValid = price > 0;\n    }\n\n    /**\n     * @notice Encodes the constant price into bytes.\n     *\n     * @param _price  The constant price in base units.\n     *\n     * @return        Encoded bytes representing the constant price.\n     */\n    function getEncodedData(uint256 _price) external pure returns (bytes memory) {\n        return abi.encode(_price);\n    }\n\n    /**\n     * @dev Decodes the constant price from the provided bytes.\n     *\n     * @param _data  Encoded bytes representing the constant price.\n     *\n     * @return       The constant price decoded from bytes in base units.\n     */\n    function getDecodedData(bytes memory _data) public pure returns (uint256) {\n        return abi.decode(_data, (uint256));\n    }\n}\n"
    },
    "solady/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, either due to a\n    /// multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The multiply-divide operation failed, either due to a\n    /// multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The output is undefined, as the input is zero.\n    error Log2Undefined();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                // Store the function selector of `MulWadFailed()`.\n                mstore(0x00, 0xbac65e5b)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                // Store the function selector of `MulWadFailed()`.\n                mstore(0x00, 0xbac65e5b)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                // Store the function selector of `DivWadFailed()`.\n                mstore(0x00, 0x7c5f487d)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                // Store the function selector of `DivWadFailed()`.\n                mstore(0x00, 0x7c5f487d)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n                // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n                if iszero(slt(x, 135305999368893231589)) {\n                    // Store the function selector of `ExpOverflow()`.\n                    mstore(0x00, 0xa37bfec9)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            /// @solidity memory-safe-assembly\n            assembly {\n                if iszero(sgt(x, 0)) {\n                    // Store the function selector of `LnWadUndefined()`.\n                    mstore(0x00, 0x1615e638)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Compute k = log2(x) - 96.\n            int256 k;\n            /// @solidity memory-safe-assembly\n            assembly {\n                let v := x\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, v))\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, v))))\n                k := or(k, shl(5, lt(0xffffffff, shr(k, v))))\n\n                // For the remaining 32 bits, use a De Bruijn lookup.\n                // See: https://graphics.stanford.edu/~seander/bithacks.html\n                v := shr(k, v)\n                v := or(v, shr(1, v))\n                v := or(v, shr(2, v))\n                v := or(v, shr(4, v))\n                v := or(v, shr(8, v))\n                v := or(v, shr(16, v))\n\n                // forgefmt: disable-next-item\n                k := sub(or(k, byte(shr(251, mul(v, shl(224, 0x07c4acdd))),\n                    0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)), 96)\n            }\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549…\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Calculates `floor(a * b / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            for {} 1 {} {\n                // 512-bit multiply `[prod1 prod0] = x * y`.\n                // Compute the product mod `2**256` and mod `2**256 - 1`\n                // then use the Chinese Remainder Theorem to reconstruct\n                // the 512 bit result. The result is stored in two 256\n                // variables such that `product = prod1 * 2**256 + prod0`.\n\n                // Least significant 256 bits of the product.\n                let prod0 := mul(x, y)\n                let mm := mulmod(x, y, not(0))\n                // Most significant 256 bits of the product.\n                let prod1 := sub(mm, add(prod0, lt(mm, prod0)))\n\n                // Handle non-overflow cases, 256 by 256 division.\n                if iszero(prod1) {\n                    if iszero(d) {\n                        // Store the function selector of `FullMulDivFailed()`.\n                        mstore(0x00, 0xae47f702)\n                        // Revert with (offset, size).\n                        revert(0x1c, 0x04)\n                    }\n                    result := div(prod0, d)\n                    break       \n                }\n\n                // Make sure the result is less than `2**256`.\n                // Also prevents `d == 0`.\n                if iszero(gt(d, prod1)) {\n                    // Store the function selector of `FullMulDivFailed()`.\n                    mstore(0x00, 0xae47f702)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n\n                ///////////////////////////////////////////////\n                // 512 by 256 division.\n                ///////////////////////////////////////////////\n\n                // Make division exact by subtracting the remainder from `[prod1 prod0]`.\n                // Compute remainder using mulmod.\n                let remainder := mulmod(x, y, d)\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n                // Factor powers of two out of `d`.\n                // Compute largest power of two divisor of `d`.\n                // Always greater or equal to 1.\n                let twos := and(d, sub(0, d))\n                // Divide d by power of two.\n                d := div(d, twos)\n                // Divide [prod1 prod0] by the factors of two.\n                prod0 := div(prod0, twos)\n                // Shift in bits from `prod1` into `prod0`. For this we need\n                // to flip `twos` such that it is `2**256 / twos`.\n                // If `twos` is zero, then it becomes one.\n                prod0 := or(prod0, mul(prod1, add(div(sub(0, twos), twos), 1)))\n                // Invert `d mod 2**256`\n                // Now that `d` is an odd number, it has an inverse\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                // Compute the inverse by starting with a seed that is correct\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                let inv := xor(mul(3, d), 2)\n                // Now use Newton-Raphson iteration to improve the precision.\n                // Thanks to Hensel's lifting lemma, this also works in modular\n                // arithmetic, doubling the correct bits in each step.\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                result := mul(prod0, mul(inv, sub(2, mul(d, inv)))) // inverse mod 2**256\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        result = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                if iszero(add(result, 1)) {\n                    // Store the function selector of `FullMulDivFailed()`.\n                    mstore(0x00, 0xae47f702)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n                result := add(result, 1)\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n                // Store the function selector of `MulDivFailed()`.\n                mstore(0x00, 0xad251c27)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n                // Store the function selector of `MulDivFailed()`.\n                mstore(0x00, 0xad251c27)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                // Store the function selector of `DivFailed()`.\n                mstore(0x00, 0x65244e4e)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns the square root of `x`.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`.\n            // We check `y >= 2**(k + 8)` but shift right by `k` bits\n            // each branch to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n\n            z := shl(add(div(r, 3), lt(0xf, shr(r, x))), 0xff)\n            z := div(z, byte(mod(r, 3), shl(232, 0x7f624b)))\n\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 58)) {\n                // Store the function selector of `FactorialOverflow()`.\n                mstore(0x00, 0xaba0f2a2)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            for { result := 1 } x {} {\n                result := mul(result, x)\n                x := sub(x, 1)\n            }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(x) {\n                // Store the function selector of `Log2Undefined()`.\n                mstore(0x00, 0x5be3aa5c)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n\n            // For the remaining 32 bits, use a De Bruijn lookup.\n            // See: https://graphics.stanford.edu/~seander/bithacks.html\n            x := shr(r, x)\n            x := or(x, shr(1, x))\n            x := or(x, shr(2, x))\n            x := or(x, shr(4, x))\n            x := or(x, shr(8, x))\n            x := or(x, shr(16, x))\n\n            // forgefmt: disable-next-item\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        unchecked {\n            uint256 isNotPo2;\n            assembly {\n                isNotPo2 := iszero(iszero(and(x, sub(x, 1))))\n            }\n            return log2(x) + isNotPo2;\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (((x & 1) + (y & 1)) >> 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := sub(0, shr(255, x))\n            z := xor(mask, add(mask, x))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let a := sub(y, x)\n            z := xor(a, mul(xor(a, sub(x, y)), sgt(x, y)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        z = min(max(x, minValue), maxValue);\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        z = min(max(x, minValue), maxValue);\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}