{
  "address": "0xdcae348A0E112E50Ab375b0Aff57841abB3B32C9",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_slope",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minPrice",
          "type": "uint256"
        }
      ],
      "name": "areParamsValid",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "getDecodedData",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "slope",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isDecreasing",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minPrice",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_slope",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "_isDecreasing",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "_maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minPrice",
          "type": "uint256"
        }
      ],
      "name": "getEncodedData",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_timeElapsed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_priceAdapterConfigData",
          "type": "bytes"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_priceAdapterConfigData",
          "type": "bytes"
        }
      ],
      "name": "isPriceAdapterConfigDataValid",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isValid",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xa6cea0726f590cd344c15da17d9b2faa2464115116ecf9e832ac93a96bcb2f94",
  "receipt": {
    "to": null,
    "from": "0xf8Bd793A7c9cB86e827C084D49f343F1296a8247",
    "contractAddress": "0xdcae348A0E112E50Ab375b0Aff57841abB3B32C9",
    "transactionIndex": 131,
    "gasUsed": "429778",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x07dfb7d8d73fa2a813926b7f3c37acd010cdf7b0c3b1c80113968f5545631dec",
    "transactionHash": "0xa6cea0726f590cd344c15da17d9b2faa2464115116ecf9e832ac93a96bcb2f94",
    "logs": [],
    "blockNumber": 20293160,
    "cumulativeGasUsed": "10081220",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "6799e1f7e8568b40d1b2c5fc5affffb4",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slope\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"areParamsValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"getDecodedData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slope\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDecreasing\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slope\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDecreasing\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"getEncodedData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeElapsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_priceAdapterConfigData\",\"type\":\"bytes\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_priceAdapterConfigData\",\"type\":\"bytes\"}],\"name\":\"isPriceAdapterConfigDataValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Index Coop\",\"kind\":\"dev\",\"methods\":{\"areParamsValid(uint256,uint256,uint256,uint256,uint256)\":{\"details\":\"Returns true if the price adapter parameters are valid.\",\"params\":{\"_bucketSize\":\"Time elapsed between each bucket\",\"_initialPrice\":\"Initial price of the auction\",\"_maxPrice\":\"Maximum price of the auction\",\"_minPrice\":\"Minimum price of the auction\"}},\"getDecodedData(bytes)\":{\"details\":\"Decodes the parameters from the provided bytes.\",\"params\":{\"_data\":\"Bytes encoded auction parameters\"},\"returns\":{\"bucketSize\":\"    Time elapsed between each bucket\",\"initialPrice\":\"  Initial price of the auction\",\"isDecreasing\":\"  Flag for whether the price is decreasing or increasing\",\"maxPrice\":\"      Maximum price of the auction\",\"minPrice\":\"      Minimum price of the auction\",\"slope\":\"         Slope of the linear price change\"}},\"getEncodedData(uint256,uint256,uint256,bool,uint256,uint256)\":{\"details\":\"Returns the encoded data for the price curve parameters\",\"params\":{\"_bucketSize\":\"Time elapsed between each bucket\",\"_initialPrice\":\"Initial price of the auction\",\"_isDecreasing\":\"Flag for whether the price is decreasing or increasing\",\"_maxPrice\":\"Maximum price of the auction\",\"_minPrice\":\"Minimum price of the auction\",\"_slope\":\"Slope of the linear price change\"}},\"getPrice(address,address,uint256,uint256,uint256,bytes)\":{\"details\":\"Calculates and returns the linear price.\",\"params\":{\"_priceAdapterConfigData\":\"Encoded bytes representing the linear function parameters.\",\"_timeElapsed\":\"Time elapsed since the start of the auction.\"},\"returns\":{\"price\":\"                   The price calculated using the linear function.\"}},\"isPriceAdapterConfigDataValid(bytes)\":{\"details\":\"Returns true if the price adapter is valid for the given parameters.\",\"params\":{\"_priceAdapterConfigData\":\"Encoded data for configuring the price adapter.\"},\"returns\":{\"isValid\":\"                 Boolean indicating if the adapter config data is valid.\"}}},\"title\":\"BoundedStepwiseLinearPriceAdapter\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that increases or decreases linearly in steps over time, within a bounded range. The rate of change is constant. Price formula: price = initialPrice +/- slope * timeBucket\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/auction-pricing/BoundedStepwiseLinearPriceAdapter.sol\":\"BoundedStepwiseLinearPriceAdapter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/auction-pricing/BoundedStepwiseLinearPriceAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport { FixedPointMathLib } from \\\"solady/src/utils/FixedPointMathLib.sol\\\";\\n\\n/**\\n * @title BoundedStepwiseLinearPriceAdapter\\n * @author Index Coop\\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\\n * increases or decreases linearly in steps over time, within a bounded range.\\n * The rate of change is constant.\\n * Price formula: price = initialPrice +/- slope * timeBucket\\n */\\ncontract BoundedStepwiseLinearPriceAdapter {\\n\\n    /**\\n     * @dev Calculates and returns the linear price.\\n     *\\n     * @param _timeElapsed              Time elapsed since the start of the auction.\\n     * @param _priceAdapterConfigData   Encoded bytes representing the linear function parameters.\\n     *\\n     * @return price                    The price calculated using the linear function.\\n     */\\n    function getPrice(\\n        address /* _setToken */,\\n        address /* _component */,\\n        uint256 /* _componentQuantity */,\\n        uint256 _timeElapsed,\\n        uint256 /* _duration */,\\n        bytes memory _priceAdapterConfigData\\n    )\\n        external\\n        pure\\n        returns (uint256 price)\\n    {\\n        (\\n            uint256 initialPrice,\\n            uint256 slope,\\n            uint256 bucketSize,\\n            bool isDecreasing,\\n            uint256 maxPrice,\\n            uint256 minPrice\\n        ) = getDecodedData(_priceAdapterConfigData);\\n\\n        require(\\n            areParamsValid(initialPrice, slope, bucketSize, maxPrice, minPrice),\\n            \\\"BoundedStepwiseLinearPriceAdapter: Invalid params\\\"\\n        );\\n\\n        uint256 bucket = _timeElapsed / bucketSize;\\n\\n        // Protect against priceChange overflow\\n        if (bucket > type(uint256).max / slope) {\\n            return isDecreasing ? minPrice : maxPrice;\\n        }\\n\\n        uint256 priceChange = bucket * slope;\\n\\n        if (isDecreasing) {\\n            // Protect against price underflow\\n            if (priceChange > initialPrice) {\\n                return minPrice;\\n            }\\n            return FixedPointMathLib.max(initialPrice - priceChange, minPrice);\\n        } else {\\n            // Protect against price overflow\\n            if (priceChange > type(uint256).max - initialPrice) {\\n                return maxPrice;\\n            }\\n            return FixedPointMathLib.min(initialPrice + priceChange, maxPrice);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the price adapter is valid for the given parameters.\\n     *\\n     * @param _priceAdapterConfigData   Encoded data for configuring the price adapter.\\n     *\\n     * @return isValid                  Boolean indicating if the adapter config data is valid.\\n     */\\n    function isPriceAdapterConfigDataValid(\\n        bytes memory _priceAdapterConfigData\\n    )\\n        external\\n        pure\\n        returns (bool isValid)\\n    {\\n        (\\n            uint256 initialPrice,\\n            uint256 slope,\\n            uint256 bucketSize,\\n            ,\\n            uint256 maxPrice,\\n            uint256 minPrice\\n        ) = getDecodedData(_priceAdapterConfigData);\\n\\n        return areParamsValid(initialPrice, slope, bucketSize, maxPrice, minPrice);\\n    }\\n\\n    /**\\n     * @dev Returns true if the price adapter parameters are valid.\\n     *\\n     * @param _initialPrice      Initial price of the auction\\n     * @param _bucketSize        Time elapsed between each bucket\\n     * @param _maxPrice          Maximum price of the auction\\n     * @param _minPrice          Minimum price of the auction\\n     */\\n    function areParamsValid(\\n        uint256 _initialPrice,\\n        uint256 _slope,\\n        uint256 _bucketSize,\\n        uint256 _maxPrice,\\n        uint256 _minPrice\\n    )\\n        public\\n        pure\\n        returns (bool)\\n    {\\n        return _initialPrice > 0\\n            && _slope > 0\\n            && _bucketSize > 0\\n            && _initialPrice <= _maxPrice\\n            && _initialPrice >= _minPrice;\\n    }\\n\\n    /**\\n     * @dev Returns the encoded data for the price curve parameters\\n     *\\n     * @param _initialPrice      Initial price of the auction\\n     * @param _slope             Slope of the linear price change\\n     * @param _bucketSize        Time elapsed between each bucket\\n     * @param _isDecreasing      Flag for whether the price is decreasing or increasing\\n     * @param _maxPrice          Maximum price of the auction\\n     * @param _minPrice          Minimum price of the auction\\n     */\\n    function getEncodedData(\\n        uint256 _initialPrice,\\n        uint256 _slope,\\n        uint256 _bucketSize,\\n        bool _isDecreasing,\\n        uint256 _maxPrice,\\n        uint256 _minPrice\\n    )\\n        external\\n        pure\\n        returns (bytes memory data)\\n    {\\n        return abi.encode(_initialPrice, _slope, _bucketSize, _isDecreasing, _maxPrice, _minPrice);\\n    }\\n\\n    /**\\n     * @dev Decodes the parameters from the provided bytes.\\n     *\\n     * @param _data           Bytes encoded auction parameters\\n     * @return initialPrice   Initial price of the auction\\n     * @return slope          Slope of the linear price change\\n     * @return bucketSize     Time elapsed between each bucket\\n     * @return isDecreasing   Flag for whether the price is decreasing or increasing\\n     * @return maxPrice       Maximum price of the auction\\n     * @return minPrice       Minimum price of the auction\\n     */\\n    function getDecodedData(bytes memory _data)\\n        public\\n        pure\\n        returns (uint256 initialPrice, uint256 slope, uint256 bucketSize, bool isDecreasing, uint256 maxPrice, uint256 minPrice)\\n    {\\n        return abi.decode(_data, (uint256, uint256, uint256, bool, uint256, uint256));\\n    }\\n}\\n\",\"keccak256\":\"0x959bf1d5ecc0f6467be3abaa696db164c732a75cad7fd4f55603bc5b81fe6993\",\"license\":\"Apache-2.0\"},\"solady/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error FactorialOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error DivWadFailed();\\n\\n    /// @dev The multiply-divide operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error MulDivFailed();\\n\\n    /// @dev The division failed, as the denominator is zero.\\n    error DivFailed();\\n\\n    /// @dev The full precision multiply-divide operation failed, either due\\n    /// to the result being larger than 256 bits, or a division by a zero.\\n    error FullMulDivFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /// @dev The output is undefined, as the input is zero.\\n    error Log2Undefined();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `x` to the power of `y`.\\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Using `ln(x)` means `x` must be greater than 0.\\n        return expWad((lnWad(x) * y) / int256(WAD));\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n                // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    // Store the function selector of `ExpOverflow()`.\\n                    mstore(0x00, 0xa37bfec9)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256(\\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\\n            );\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                if iszero(sgt(x, 0)) {\\n                    // Store the function selector of `LnWadUndefined()`.\\n                    mstore(0x00, 0x1615e638)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Compute k = log2(x) - 96.\\n            int256 k;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let v := x\\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, v))\\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, v))))\\n                k := or(k, shl(5, lt(0xffffffff, shr(k, v))))\\n\\n                // For the remaining 32 bits, use a De Bruijn lookup.\\n                // See: https://graphics.stanford.edu/~seander/bithacks.html\\n                v := shr(k, v)\\n                v := or(v, shr(1, v))\\n                v := or(v, shr(2, v))\\n                v := or(v, shr(4, v))\\n                v := or(v, shr(8, v))\\n                v := or(v, shr(16, v))\\n\\n                // forgefmt: disable-next-item\\n                k := sub(or(k, byte(shr(251, mul(v, shl(224, 0x07c4acdd))),\\n                    0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)), 96)\\n            }\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  GENERAL NUMBER UTILITIES                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Calculates `floor(a * b / d)` with full precision.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/21/muldiv\\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for {} 1 {} {\\n                // 512-bit multiply `[prod1 prod0] = x * y`.\\n                // Compute the product mod `2**256` and mod `2**256 - 1`\\n                // then use the Chinese Remainder Theorem to reconstruct\\n                // the 512 bit result. The result is stored in two 256\\n                // variables such that `product = prod1 * 2**256 + prod0`.\\n\\n                // Least significant 256 bits of the product.\\n                let prod0 := mul(x, y)\\n                let mm := mulmod(x, y, not(0))\\n                // Most significant 256 bits of the product.\\n                let prod1 := sub(mm, add(prod0, lt(mm, prod0)))\\n\\n                // Handle non-overflow cases, 256 by 256 division.\\n                if iszero(prod1) {\\n                    if iszero(d) {\\n                        // Store the function selector of `FullMulDivFailed()`.\\n                        mstore(0x00, 0xae47f702)\\n                        // Revert with (offset, size).\\n                        revert(0x1c, 0x04)\\n                    }\\n                    result := div(prod0, d)\\n                    break       \\n                }\\n\\n                // Make sure the result is less than `2**256`.\\n                // Also prevents `d == 0`.\\n                if iszero(gt(d, prod1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n\\n                ///////////////////////////////////////////////\\n                // 512 by 256 division.\\n                ///////////////////////////////////////////////\\n\\n                // Make division exact by subtracting the remainder from `[prod1 prod0]`.\\n                // Compute remainder using mulmod.\\n                let remainder := mulmod(x, y, d)\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n                // Factor powers of two out of `d`.\\n                // Compute largest power of two divisor of `d`.\\n                // Always greater or equal to 1.\\n                let twos := and(d, sub(0, d))\\n                // Divide d by power of two.\\n                d := div(d, twos)\\n                // Divide [prod1 prod0] by the factors of two.\\n                prod0 := div(prod0, twos)\\n                // Shift in bits from `prod1` into `prod0`. For this we need\\n                // to flip `twos` such that it is `2**256 / twos`.\\n                // If `twos` is zero, then it becomes one.\\n                prod0 := or(prod0, mul(prod1, add(div(sub(0, twos), twos), 1)))\\n                // Invert `d mod 2**256`\\n                // Now that `d` is an odd number, it has an inverse\\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\\n                // Compute the inverse by starting with a seed that is correct\\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\\n                let inv := xor(mul(3, d), 2)\\n                // Now use Newton-Raphson iteration to improve the precision.\\n                // Thanks to Hensel's lifting lemma, this also works in modular\\n                // arithmetic, doubling the correct bits in each step.\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\\n                result := mul(prod0, mul(inv, sub(2, mul(d, inv)))) // inverse mod 2**256\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Uniswap-v3-core under MIT license:\\n    /// https://github.com/Uniswap/v3-core/blob/contracts/libraries/FullMath.sol\\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        result = fullMulDiv(x, y, d);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mulmod(x, y, d) {\\n                if iszero(add(result, 1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n                result := add(result, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `floor(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), d)\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x / d)`.\\n    /// Reverts if `d` is zero.\\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(d) {\\n                // Store the function selector of `DivFailed()`.\\n                mstore(0x00, 0x65244e4e)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`.\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // Let `y = x / 2**r`.\\n            // We check `y >= 2**(k + 8)` but shift right by `k` bits\\n            // each branch to ensure that if `x >= 256`, then `y >= 256`.\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\\n            z := shl(shr(1, r), z)\\n\\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\\n\\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\\n\\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\\n\\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\\n            // Then we can estimate `sqrt(y)` using\\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\\n\\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If `x+1` is a perfect square, the Babylonian method cycles between\\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    /// @dev Returns the cube root of `x`.\\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n\\n            z := shl(add(div(r, 3), lt(0xf, shr(r, x))), 0xff)\\n            z := div(z, byte(mod(r, 3), shl(232, 0x7f624b)))\\n\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n\\n            z := sub(z, lt(div(x, mul(z, z)), z))\\n        }\\n    }\\n\\n    /// @dev Returns the factorial of `x`.\\n    function factorial(uint256 x) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, 58)) {\\n                // Store the function selector of `FactorialOverflow()`.\\n                mstore(0x00, 0xaba0f2a2)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            for { result := 1 } x {} {\\n                result := mul(result, x)\\n                x := sub(x, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`.\\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(x) {\\n                // Store the function selector of `Log2Undefined()`.\\n                mstore(0x00, 0x5be3aa5c)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // See: https://graphics.stanford.edu/~seander/bithacks.html\\n            x := shr(r, x)\\n            x := or(x, shr(1, x))\\n            x := or(x, shr(2, x))\\n            x := or(x, shr(4, x))\\n            x := or(x, shr(8, x))\\n            x := or(x, shr(16, x))\\n\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`, rounded up.\\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\\n        unchecked {\\n            uint256 isNotPo2;\\n            assembly {\\n                isNotPo2 := iszero(iszero(and(x, sub(x, 1))))\\n            }\\n            return log2(x) + isNotPo2;\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = (x & y) + ((x ^ y) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = (x >> 1) + (y >> 1) + (((x & 1) + (y & 1)) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the absolute value of `x`.\\n    function abs(int256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := sub(0, shr(255, x))\\n            z := xor(mask, add(mask, x))\\n        }\\n    }\\n\\n    /// @dev Returns the absolute distance between `x` and `y`.\\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let a := sub(y, x)\\n            z := xor(a, mul(xor(a, sub(x, y)), sgt(x, y)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns greatest common divisor of `x` and `y`.\\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for { z := x } y {} {\\n                let t := y\\n                y := mod(z, y)\\n                z := t\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RAW NUMBER OPERATIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := smod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := addmod(x, y, d)\\n        }\\n    }\\n\\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mulmod(x, y, d)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd665d762c3c415f9227b326d0e6c814f0366eb6c5dd3283de5fcdc028e6a07f5\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506106d0806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c8063079f6bf41461005c578063104b9b641461008457806363dc2e6b146100a5578063bf160e2514610105578063d3516db614610118575b600080fd5b61006f61006a36600461040a565b61015a565b60405190151581526020015b60405180910390f35b610097610092366004610463565b61018f565b60405190815260200161007b565b6100f86100b33660046104ee565b604080516020810197909752868101959095526060860193909352901515608085015260a084015260c0808401919091528151808403909101815260e0909201905290565b60405161007b9190610541565b61006f61011336600461058f565b6102fa565b61012b61012636600461040a565b610336565b6040805196875260208701959095529385019290925215156060840152608083015260a082015260c00161007b565b60008060008060008061016c87610336565b955095505094509450945061018485858585856102fa565b979650505050505050565b60008060008060008060006101a388610336565b9550955095509550955095506101bc86868685856102fa565b6102265760405162461bcd60e51b815260206004820152603160248201527f426f756e64656453746570776973654c696e6561725072696365416461707465604482015270723a20496e76616c696420706172616d7360781b606482015260840160405180910390fd5b6000610232858c6105e0565b9050610240866000196105e0565b81111561026257836102525782610254565b815b9750505050505050506102f0565b600061026e8783610602565b905084156102b5578781111561028e5782985050505050505050506102f0565b6102a661029b828a61061f565b848110818618021890565b985050505050505050506102f0565b6102c18860001961061f565b8111156102d85783985050505050505050506102f0565b6102a66102e5828a610632565b858111818718021890565b9695505050505050565b6000808611801561030b5750600085115b80156103175750600084115b80156103235750828611155b80156102f0575050909310159392505050565b600080600080600080868060200190518101906103539190610645565b949c939b5091995097509550909350915050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261038e57600080fd5b813567ffffffffffffffff808211156103a9576103a9610367565b604051601f8301601f19908116603f011681019082821181831017156103d1576103d1610367565b816040528381528660208588010111156103ea57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561041c57600080fd5b813567ffffffffffffffff81111561043357600080fd5b61043f8482850161037d565b949350505050565b80356001600160a01b038116811461045e57600080fd5b919050565b60008060008060008060c0878903121561047c57600080fd5b61048587610447565b955061049360208801610447565b945060408701359350606087013592506080870135915060a087013567ffffffffffffffff8111156104c457600080fd5b6104d089828a0161037d565b9150509295509295509295565b80151581146104eb57600080fd5b50565b60008060008060008060c0878903121561050757600080fd5b8635955060208701359450604087013593506060870135610527816104dd565b9598949750929560808101359460a0909101359350915050565b600060208083528351808285015260005b8181101561056e57858101830151858201604001528201610552565b506000604082860101526040601f19601f8301168501019250505092915050565b600080600080600060a086880312156105a757600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b634e487b7160e01b600052601160045260246000fd5b6000826105fd57634e487b7160e01b600052601260045260246000fd5b500490565b8082028115828204841417610619576106196105ca565b92915050565b81810381811115610619576106196105ca565b80820180821115610619576106196105ca565b60008060008060008060c0878903121561065e57600080fd5b865195506020870151945060408701519350606087015161067e816104dd565b809350506080870151915060a08701519050929550929550929556fea264697066735822122057ffce8aaf6c11ff96c11be940cf5dee241ba998c8a82b2233607278f1085aeb64736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c8063079f6bf41461005c578063104b9b641461008457806363dc2e6b146100a5578063bf160e2514610105578063d3516db614610118575b600080fd5b61006f61006a36600461040a565b61015a565b60405190151581526020015b60405180910390f35b610097610092366004610463565b61018f565b60405190815260200161007b565b6100f86100b33660046104ee565b604080516020810197909752868101959095526060860193909352901515608085015260a084015260c0808401919091528151808403909101815260e0909201905290565b60405161007b9190610541565b61006f61011336600461058f565b6102fa565b61012b61012636600461040a565b610336565b6040805196875260208701959095529385019290925215156060840152608083015260a082015260c00161007b565b60008060008060008061016c87610336565b955095505094509450945061018485858585856102fa565b979650505050505050565b60008060008060008060006101a388610336565b9550955095509550955095506101bc86868685856102fa565b6102265760405162461bcd60e51b815260206004820152603160248201527f426f756e64656453746570776973654c696e6561725072696365416461707465604482015270723a20496e76616c696420706172616d7360781b606482015260840160405180910390fd5b6000610232858c6105e0565b9050610240866000196105e0565b81111561026257836102525782610254565b815b9750505050505050506102f0565b600061026e8783610602565b905084156102b5578781111561028e5782985050505050505050506102f0565b6102a661029b828a61061f565b848110818618021890565b985050505050505050506102f0565b6102c18860001961061f565b8111156102d85783985050505050505050506102f0565b6102a66102e5828a610632565b858111818718021890565b9695505050505050565b6000808611801561030b5750600085115b80156103175750600084115b80156103235750828611155b80156102f0575050909310159392505050565b600080600080600080868060200190518101906103539190610645565b949c939b5091995097509550909350915050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261038e57600080fd5b813567ffffffffffffffff808211156103a9576103a9610367565b604051601f8301601f19908116603f011681019082821181831017156103d1576103d1610367565b816040528381528660208588010111156103ea57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561041c57600080fd5b813567ffffffffffffffff81111561043357600080fd5b61043f8482850161037d565b949350505050565b80356001600160a01b038116811461045e57600080fd5b919050565b60008060008060008060c0878903121561047c57600080fd5b61048587610447565b955061049360208801610447565b945060408701359350606087013592506080870135915060a087013567ffffffffffffffff8111156104c457600080fd5b6104d089828a0161037d565b9150509295509295509295565b80151581146104eb57600080fd5b50565b60008060008060008060c0878903121561050757600080fd5b8635955060208701359450604087013593506060870135610527816104dd565b9598949750929560808101359460a0909101359350915050565b600060208083528351808285015260005b8181101561056e57858101830151858201604001528201610552565b506000604082860101526040601f19601f8301168501019250505092915050565b600080600080600060a086880312156105a757600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b634e487b7160e01b600052601160045260246000fd5b6000826105fd57634e487b7160e01b600052601260045260246000fd5b500490565b8082028115828204841417610619576106196105ca565b92915050565b81810381811115610619576106196105ca565b80820180821115610619576106196105ca565b60008060008060008060c0878903121561065e57600080fd5b865195506020870151945060408701519350606087015161067e816104dd565b809350506080870151915060a08701519050929550929550929556fea264697066735822122057ffce8aaf6c11ff96c11be940cf5dee241ba998c8a82b2233607278f1085aeb64736f6c63430008110033",
  "devdoc": {
    "author": "Index Coop",
    "kind": "dev",
    "methods": {
      "areParamsValid(uint256,uint256,uint256,uint256,uint256)": {
        "details": "Returns true if the price adapter parameters are valid.",
        "params": {
          "_bucketSize": "Time elapsed between each bucket",
          "_initialPrice": "Initial price of the auction",
          "_maxPrice": "Maximum price of the auction",
          "_minPrice": "Minimum price of the auction"
        }
      },
      "getDecodedData(bytes)": {
        "details": "Decodes the parameters from the provided bytes.",
        "params": {
          "_data": "Bytes encoded auction parameters"
        },
        "returns": {
          "bucketSize": "    Time elapsed between each bucket",
          "initialPrice": "  Initial price of the auction",
          "isDecreasing": "  Flag for whether the price is decreasing or increasing",
          "maxPrice": "      Maximum price of the auction",
          "minPrice": "      Minimum price of the auction",
          "slope": "         Slope of the linear price change"
        }
      },
      "getEncodedData(uint256,uint256,uint256,bool,uint256,uint256)": {
        "details": "Returns the encoded data for the price curve parameters",
        "params": {
          "_bucketSize": "Time elapsed between each bucket",
          "_initialPrice": "Initial price of the auction",
          "_isDecreasing": "Flag for whether the price is decreasing or increasing",
          "_maxPrice": "Maximum price of the auction",
          "_minPrice": "Minimum price of the auction",
          "_slope": "Slope of the linear price change"
        }
      },
      "getPrice(address,address,uint256,uint256,uint256,bytes)": {
        "details": "Calculates and returns the linear price.",
        "params": {
          "_priceAdapterConfigData": "Encoded bytes representing the linear function parameters.",
          "_timeElapsed": "Time elapsed since the start of the auction."
        },
        "returns": {
          "price": "                   The price calculated using the linear function."
        }
      },
      "isPriceAdapterConfigDataValid(bytes)": {
        "details": "Returns true if the price adapter is valid for the given parameters.",
        "params": {
          "_priceAdapterConfigData": "Encoded data for configuring the price adapter."
        },
        "returns": {
          "isValid": "                 Boolean indicating if the adapter config data is valid."
        }
      }
    },
    "title": "BoundedStepwiseLinearPriceAdapter",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that increases or decreases linearly in steps over time, within a bounded range. The rate of change is constant. Price formula: price = initialPrice +/- slope * timeBucket",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}