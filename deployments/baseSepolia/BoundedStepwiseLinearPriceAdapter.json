{
  "address": "0xaaF93f789809694b7e4acB378b24bEab52cD412c",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_slope",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minPrice",
          "type": "uint256"
        }
      ],
      "name": "areParamsValid",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "getDecodedData",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "slope",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isDecreasing",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minPrice",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_slope",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "_isDecreasing",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "_maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minPrice",
          "type": "uint256"
        }
      ],
      "name": "getEncodedData",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_timeElapsed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_priceAdapterConfigData",
          "type": "bytes"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_priceAdapterConfigData",
          "type": "bytes"
        }
      ],
      "name": "isPriceAdapterConfigDataValid",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isValid",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x751f5bd1d878c9fb92de6e91cd4a352ebeb8fcecaccbd961f726e02a29940661",
  "receipt": {
    "to": null,
    "from": "0x570f581D23a2AB09FD1990279D9DB6f5DcE18F4A",
    "contractAddress": "0xaaF93f789809694b7e4acB378b24bEab52cD412c",
    "transactionIndex": 6,
    "gasUsed": "429990",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7c0aaf5f4e8a9a1710e6233bbd67cecb1cfef2913d1f67fbbfed5d91849404fa",
    "transactionHash": "0x751f5bd1d878c9fb92de6e91cd4a352ebeb8fcecaccbd961f726e02a29940661",
    "logs": [],
    "blockNumber": 10256197,
    "cumulativeGasUsed": "1386736",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "7fe3b69caaa6e1ae3cb624acb9fde77a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slope\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"areParamsValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"getDecodedData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slope\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDecreasing\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slope\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDecreasing\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"getEncodedData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeElapsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_priceAdapterConfigData\",\"type\":\"bytes\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_priceAdapterConfigData\",\"type\":\"bytes\"}],\"name\":\"isPriceAdapterConfigDataValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"areParamsValid(uint256,uint256,uint256,uint256,uint256)\":{\"details\":\"Returns true if the price adapter parameters are valid.\",\"params\":{\"_bucketSize\":\"Time elapsed between each bucket\",\"_initialPrice\":\"Initial price of the auction\",\"_maxPrice\":\"Maximum price of the auction\",\"_minPrice\":\"Minimum price of the auction\"}},\"getDecodedData(bytes)\":{\"details\":\"Decodes the parameters from the provided bytes.\",\"params\":{\"_data\":\"Bytes encoded auction parameters\"},\"returns\":{\"bucketSize\":\"    Time elapsed between each bucket\",\"initialPrice\":\"  Initial price of the auction\",\"isDecreasing\":\"  Flag for whether the price is decreasing or increasing\",\"maxPrice\":\"      Maximum price of the auction\",\"minPrice\":\"      Minimum price of the auction\",\"slope\":\"         Slope of the linear price change\"}},\"getEncodedData(uint256,uint256,uint256,bool,uint256,uint256)\":{\"details\":\"Returns the encoded data for the price curve parameters\",\"params\":{\"_bucketSize\":\"Time elapsed between each bucket\",\"_initialPrice\":\"Initial price of the auction\",\"_isDecreasing\":\"Flag for whether the price is decreasing or increasing\",\"_maxPrice\":\"Maximum price of the auction\",\"_minPrice\":\"Minimum price of the auction\",\"_slope\":\"Slope of the linear price change\"}},\"getPrice(address,address,uint256,uint256,uint256,bytes)\":{\"details\":\"Calculates and returns the linear price.\",\"params\":{\"_priceAdapterConfigData\":\"Encoded bytes representing the linear function parameters.\",\"_timeElapsed\":\"Time elapsed since the start of the auction.\"},\"returns\":{\"price\":\"                   The price calculated using the linear function.\"}},\"isPriceAdapterConfigDataValid(bytes)\":{\"details\":\"Returns true if the price adapter is valid for the given parameters.\",\"params\":{\"_priceAdapterConfigData\":\"Encoded data for configuring the price adapter.\"},\"returns\":{\"isValid\":\"                 Boolean indicating if the adapter config data is valid.\"}}},\"title\":\"BoundedStepwiseLinearPriceAdapter\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that increases or decreases linearly in steps over time, within a bounded range. The rate of change is constant. Price formula: price = initialPrice +/- slope * timeBucket\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/auction-pricing/BoundedStepwiseLinearPriceAdapter.sol\":\"BoundedStepwiseLinearPriceAdapter\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/auction-pricing/BoundedStepwiseLinearPriceAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.25;\\n\\nimport { FixedPointMathLib } from \\\"../lib/FixedPointMathLib.sol\\\";\\n\\n/**\\n * @title BoundedStepwiseLinearPriceAdapter\\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\\n * increases or decreases linearly in steps over time, within a bounded range.\\n * The rate of change is constant.\\n * Price formula: price = initialPrice +/- slope * timeBucket\\n */\\ncontract BoundedStepwiseLinearPriceAdapter {\\n\\n    /**\\n     * @dev Calculates and returns the linear price.\\n     *\\n     * @param _timeElapsed              Time elapsed since the start of the auction.\\n     * @param _priceAdapterConfigData   Encoded bytes representing the linear function parameters.\\n     *\\n     * @return price                    The price calculated using the linear function.\\n     */\\n    function getPrice(\\n        address /* _setToken */,\\n        address /* _component */,\\n        uint256 /* _componentQuantity */,\\n        uint256 _timeElapsed,\\n        uint256 /* _duration */,\\n        bytes memory _priceAdapterConfigData\\n    )\\n        external\\n        pure\\n        returns (uint256 price)\\n    {\\n        (\\n            uint256 initialPrice,\\n            uint256 slope,\\n            uint256 bucketSize,\\n            bool isDecreasing,\\n            uint256 maxPrice,\\n            uint256 minPrice\\n        ) = getDecodedData(_priceAdapterConfigData);\\n\\n        require(\\n            areParamsValid(initialPrice, slope, bucketSize, maxPrice, minPrice),\\n            \\\"BoundedStepwiseLinearPriceAdapter: Invalid params\\\"\\n        );\\n\\n        uint256 bucket = _timeElapsed / bucketSize;\\n\\n        // Protect against priceChange overflow\\n        if (bucket > type(uint256).max / slope) {\\n            return isDecreasing ? minPrice : maxPrice;\\n        }\\n\\n        uint256 priceChange = bucket * slope;\\n\\n        if (isDecreasing) {\\n            // Protect against price underflow\\n            if (priceChange > initialPrice) {\\n                return minPrice;\\n            }\\n            return FixedPointMathLib.max(initialPrice - priceChange, minPrice);\\n        } else {\\n            // Protect against price overflow\\n            if (priceChange > type(uint256).max - initialPrice) {\\n                return maxPrice;\\n            }\\n            return FixedPointMathLib.min(initialPrice + priceChange, maxPrice);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the price adapter is valid for the given parameters.\\n     *\\n     * @param _priceAdapterConfigData   Encoded data for configuring the price adapter.\\n     *\\n     * @return isValid                  Boolean indicating if the adapter config data is valid.\\n     */\\n    function isPriceAdapterConfigDataValid(\\n        bytes memory _priceAdapterConfigData\\n    )\\n        external\\n        pure\\n        returns (bool isValid)\\n    {\\n        (\\n            uint256 initialPrice,\\n            uint256 slope,\\n            uint256 bucketSize,\\n            ,\\n            uint256 maxPrice,\\n            uint256 minPrice\\n        ) = getDecodedData(_priceAdapterConfigData);\\n\\n        return areParamsValid(initialPrice, slope, bucketSize, maxPrice, minPrice);\\n    }\\n\\n    /**\\n     * @dev Returns true if the price adapter parameters are valid.\\n     *\\n     * @param _initialPrice      Initial price of the auction\\n     * @param _bucketSize        Time elapsed between each bucket\\n     * @param _maxPrice          Maximum price of the auction\\n     * @param _minPrice          Minimum price of the auction\\n     */\\n    function areParamsValid(\\n        uint256 _initialPrice,\\n        uint256 _slope,\\n        uint256 _bucketSize,\\n        uint256 _maxPrice,\\n        uint256 _minPrice\\n    )\\n        public\\n        pure\\n        returns (bool)\\n    {\\n        return _initialPrice > 0\\n            && _slope > 0\\n            && _bucketSize > 0\\n            && _initialPrice <= _maxPrice\\n            && _initialPrice >= _minPrice;\\n    }\\n\\n    /**\\n     * @dev Returns the encoded data for the price curve parameters\\n     *\\n     * @param _initialPrice      Initial price of the auction\\n     * @param _slope             Slope of the linear price change\\n     * @param _bucketSize        Time elapsed between each bucket\\n     * @param _isDecreasing      Flag for whether the price is decreasing or increasing\\n     * @param _maxPrice          Maximum price of the auction\\n     * @param _minPrice          Minimum price of the auction\\n     */\\n    function getEncodedData(\\n        uint256 _initialPrice,\\n        uint256 _slope,\\n        uint256 _bucketSize,\\n        bool _isDecreasing,\\n        uint256 _maxPrice,\\n        uint256 _minPrice\\n    )\\n        external\\n        pure\\n        returns (bytes memory data)\\n    {\\n        return abi.encode(_initialPrice, _slope, _bucketSize, _isDecreasing, _maxPrice, _minPrice);\\n    }\\n\\n    /**\\n     * @dev Decodes the parameters from the provided bytes.\\n     *\\n     * @param _data           Bytes encoded auction parameters\\n     * @return initialPrice   Initial price of the auction\\n     * @return slope          Slope of the linear price change\\n     * @return bucketSize     Time elapsed between each bucket\\n     * @return isDecreasing   Flag for whether the price is decreasing or increasing\\n     * @return maxPrice       Maximum price of the auction\\n     * @return minPrice       Minimum price of the auction\\n     */\\n    function getDecodedData(bytes memory _data)\\n        public\\n        pure\\n        returns (uint256 initialPrice, uint256 slope, uint256 bucketSize, bool isDecreasing, uint256 maxPrice, uint256 minPrice)\\n    {\\n        return abi.decode(_data, (uint256, uint256, uint256, bool, uint256, uint256));\\n    }\\n}\\n\",\"keccak256\":\"0x57018293dffcd13aaf1575e7cc0e319c95fa4ff44b6b17edc723eb67a9b5a93c\",\"license\":\"Apache-2.0\"},\"contracts/lib/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/22/exp-ln\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is less than 0.5 we return zero.\\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\\n            if (x <= -41446531673892822313) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) \\u2248 135`.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // `k` is in the range `[-61, 195]`.\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // `p` is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already `2**96` too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range `(0.09, 0.25) * 2**96`.\\n\\n            // We now need to multiply r by:\\n            // - The scale factor `s \\u2248 6.031367120`.\\n            // - The `2**k` factor from the range reduction.\\n            // - The `1e18 / 2**96` factor for base conversion.\\n            // We do this all at once, with an intermediate result in `2**213`\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256(\\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\\n            );\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/22/exp-ln\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\\n            // We do this by multiplying by `2**96 / 10**18`. But since\\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\\n            // and add `ln(2**96 / 10**18)` at the end.\\n\\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // We place the check here for more optimal stack operations.\\n            if iszero(sgt(x, 0)) {\\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // forgefmt: disable-next-item\\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x := shr(159, shl(r, x))\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // `p` is made monic, we will multiply by a scale factor later.\\n            // forgefmt: disable-next-item\\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\\n                sar(96, mul(add(43456485725739037958740375743393,\\n                sar(96, mul(add(24828157081833163892658089445524,\\n                sar(96, mul(add(3273285459638523848632254066296,\\n                    x), x))), x))), x)), 11111509109440967052023855526967)\\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\\n\\n            // `q` is monic by convention.\\n            let q := add(5573035233440673466300451813936, x)\\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\\n\\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\\n\\n            // Finalization, we need to:\\n            // - Multiply by the scale factor `s = 5.549\\u2026`.\\n            // - Add `ln(2**96 / 10**18)`.\\n            // - Add `k * ln(2)`.\\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\\n\\n            // The q polynomial is known not to have zeros in the domain.\\n            // No scaling required because p is already `2**96` too large.\\n            p := sdiv(p, q)\\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\\n            p := mul(1677202110996718588342820967067443963516166, p)\\n            // Add `ln(2) * k * 5**18 * 2**192`.\\n            // forgefmt: disable-next-item\\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\\n            // Base conversion: mul `2**18 / 2**192`.\\n            r := sar(174, p)\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x93036622f2af31d328d5c3aa7701507610024e0f9f14dc19724350c565d3fcee\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600f57600080fd5b506106d18061001f6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c8063079f6bf41461005c578063104b9b641461008457806363dc2e6b146100a5578063bf160e2514610105578063d3516db614610118575b600080fd5b61006f61006a36600461040a565b61015a565b60405190151581526020015b60405180910390f35b610097610092366004610463565b61018f565b60405190815260200161007b565b6100f86100b33660046104ee565b604080516020810197909752868101959095526060860193909352901515608085015260a084015260c0808401919091528151808403909101815260e0909201905290565b60405161007b9190610541565b61006f610113366004610590565b6102fa565b61012b61012636600461040a565b610336565b6040805196875260208701959095529385019290925215156060840152608083015260a082015260c00161007b565b60008060008060008061016c87610336565b955095505094509450945061018485858585856102fa565b979650505050505050565b60008060008060008060006101a388610336565b9550955095509550955095506101bc86868685856102fa565b6102265760405162461bcd60e51b815260206004820152603160248201527f426f756e64656453746570776973654c696e6561725072696365416461707465604482015270723a20496e76616c696420706172616d7360781b606482015260840160405180910390fd5b6000610232858c6105e1565b9050610240866000196105e1565b81111561026257836102525782610254565b815b9750505050505050506102f0565b600061026e8783610603565b905084156102b5578781111561028e5782985050505050505050506102f0565b6102a661029b828a610620565b848110818618021890565b985050505050505050506102f0565b6102c188600019610620565b8111156102d85783985050505050505050506102f0565b6102a66102e5828a610633565b858111818718021890565b9695505050505050565b6000808611801561030b5750600085115b80156103175750600084115b80156103235750828611155b80156102f0575050909310159392505050565b600080600080600080868060200190518101906103539190610646565b949c939b5091995097509550909350915050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261038e57600080fd5b813567ffffffffffffffff808211156103a9576103a9610367565b604051601f8301601f19908116603f011681019082821181831017156103d1576103d1610367565b816040528381528660208588010111156103ea57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561041c57600080fd5b813567ffffffffffffffff81111561043357600080fd5b61043f8482850161037d565b949350505050565b80356001600160a01b038116811461045e57600080fd5b919050565b60008060008060008060c0878903121561047c57600080fd5b61048587610447565b955061049360208801610447565b945060408701359350606087013592506080870135915060a087013567ffffffffffffffff8111156104c457600080fd5b6104d089828a0161037d565b9150509295509295509295565b80151581146104eb57600080fd5b50565b60008060008060008060c0878903121561050757600080fd5b8635955060208701359450604087013593506060870135610527816104dd565b9598949750929560808101359460a0909101359350915050565b60006020808352835180602085015260005b8181101561056f57858101830151858201604001528201610553565b506000604082860101526040601f19601f8301168501019250505092915050565b600080600080600060a086880312156105a857600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b634e487b7160e01b600052601160045260246000fd5b6000826105fe57634e487b7160e01b600052601260045260246000fd5b500490565b808202811582820484141761061a5761061a6105cb565b92915050565b8181038181111561061a5761061a6105cb565b8082018082111561061a5761061a6105cb565b60008060008060008060c0878903121561065f57600080fd5b865195506020870151945060408701519350606087015161067f816104dd565b809350506080870151915060a08701519050929550929550929556fea26469706673582212208c4a7fa1ec48ac964a2a1596ed1a15ce11ce0e918bc63a6ff58d40556762e25564736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c8063079f6bf41461005c578063104b9b641461008457806363dc2e6b146100a5578063bf160e2514610105578063d3516db614610118575b600080fd5b61006f61006a36600461040a565b61015a565b60405190151581526020015b60405180910390f35b610097610092366004610463565b61018f565b60405190815260200161007b565b6100f86100b33660046104ee565b604080516020810197909752868101959095526060860193909352901515608085015260a084015260c0808401919091528151808403909101815260e0909201905290565b60405161007b9190610541565b61006f610113366004610590565b6102fa565b61012b61012636600461040a565b610336565b6040805196875260208701959095529385019290925215156060840152608083015260a082015260c00161007b565b60008060008060008061016c87610336565b955095505094509450945061018485858585856102fa565b979650505050505050565b60008060008060008060006101a388610336565b9550955095509550955095506101bc86868685856102fa565b6102265760405162461bcd60e51b815260206004820152603160248201527f426f756e64656453746570776973654c696e6561725072696365416461707465604482015270723a20496e76616c696420706172616d7360781b606482015260840160405180910390fd5b6000610232858c6105e1565b9050610240866000196105e1565b81111561026257836102525782610254565b815b9750505050505050506102f0565b600061026e8783610603565b905084156102b5578781111561028e5782985050505050505050506102f0565b6102a661029b828a610620565b848110818618021890565b985050505050505050506102f0565b6102c188600019610620565b8111156102d85783985050505050505050506102f0565b6102a66102e5828a610633565b858111818718021890565b9695505050505050565b6000808611801561030b5750600085115b80156103175750600084115b80156103235750828611155b80156102f0575050909310159392505050565b600080600080600080868060200190518101906103539190610646565b949c939b5091995097509550909350915050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261038e57600080fd5b813567ffffffffffffffff808211156103a9576103a9610367565b604051601f8301601f19908116603f011681019082821181831017156103d1576103d1610367565b816040528381528660208588010111156103ea57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561041c57600080fd5b813567ffffffffffffffff81111561043357600080fd5b61043f8482850161037d565b949350505050565b80356001600160a01b038116811461045e57600080fd5b919050565b60008060008060008060c0878903121561047c57600080fd5b61048587610447565b955061049360208801610447565b945060408701359350606087013592506080870135915060a087013567ffffffffffffffff8111156104c457600080fd5b6104d089828a0161037d565b9150509295509295509295565b80151581146104eb57600080fd5b50565b60008060008060008060c0878903121561050757600080fd5b8635955060208701359450604087013593506060870135610527816104dd565b9598949750929560808101359460a0909101359350915050565b60006020808352835180602085015260005b8181101561056f57858101830151858201604001528201610553565b506000604082860101526040601f19601f8301168501019250505092915050565b600080600080600060a086880312156105a857600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b634e487b7160e01b600052601160045260246000fd5b6000826105fe57634e487b7160e01b600052601260045260246000fd5b500490565b808202811582820484141761061a5761061a6105cb565b92915050565b8181038181111561061a5761061a6105cb565b8082018082111561061a5761061a6105cb565b60008060008060008060c0878903121561065f57600080fd5b865195506020870151945060408701519350606087015161067f816104dd565b809350506080870151915060a08701519050929550929550929556fea26469706673582212208c4a7fa1ec48ac964a2a1596ed1a15ce11ce0e918bc63a6ff58d40556762e25564736f6c63430008190033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "areParamsValid(uint256,uint256,uint256,uint256,uint256)": {
        "details": "Returns true if the price adapter parameters are valid.",
        "params": {
          "_bucketSize": "Time elapsed between each bucket",
          "_initialPrice": "Initial price of the auction",
          "_maxPrice": "Maximum price of the auction",
          "_minPrice": "Minimum price of the auction"
        }
      },
      "getDecodedData(bytes)": {
        "details": "Decodes the parameters from the provided bytes.",
        "params": {
          "_data": "Bytes encoded auction parameters"
        },
        "returns": {
          "bucketSize": "    Time elapsed between each bucket",
          "initialPrice": "  Initial price of the auction",
          "isDecreasing": "  Flag for whether the price is decreasing or increasing",
          "maxPrice": "      Maximum price of the auction",
          "minPrice": "      Minimum price of the auction",
          "slope": "         Slope of the linear price change"
        }
      },
      "getEncodedData(uint256,uint256,uint256,bool,uint256,uint256)": {
        "details": "Returns the encoded data for the price curve parameters",
        "params": {
          "_bucketSize": "Time elapsed between each bucket",
          "_initialPrice": "Initial price of the auction",
          "_isDecreasing": "Flag for whether the price is decreasing or increasing",
          "_maxPrice": "Maximum price of the auction",
          "_minPrice": "Minimum price of the auction",
          "_slope": "Slope of the linear price change"
        }
      },
      "getPrice(address,address,uint256,uint256,uint256,bytes)": {
        "details": "Calculates and returns the linear price.",
        "params": {
          "_priceAdapterConfigData": "Encoded bytes representing the linear function parameters.",
          "_timeElapsed": "Time elapsed since the start of the auction."
        },
        "returns": {
          "price": "                   The price calculated using the linear function."
        }
      },
      "isPriceAdapterConfigDataValid(bytes)": {
        "details": "Returns true if the price adapter is valid for the given parameters.",
        "params": {
          "_priceAdapterConfigData": "Encoded data for configuring the price adapter."
        },
        "returns": {
          "isValid": "                 Boolean indicating if the adapter config data is valid."
        }
      }
    },
    "title": "BoundedStepwiseLinearPriceAdapter",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that increases or decreases linearly in steps over time, within a bounded range. The rate of change is constant. Price formula: price = initialPrice +/- slope * timeBucket",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}