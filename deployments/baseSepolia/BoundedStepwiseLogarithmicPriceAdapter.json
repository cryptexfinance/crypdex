{
  "address": "0xB1c27867857C095f26929E10D2Ad02718e00fCF4",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_scalingFactor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_timeCoefficient",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minPrice",
          "type": "uint256"
        }
      ],
      "name": "areParamsValid",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "getDecodedData",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "scalingFactor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "timeCoefficient",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isDecreasing",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minPrice",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_initialPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_scalingFactor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_timeCoefficient",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_bucketSize",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "_isDecreasing",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "_maxPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minPrice",
          "type": "uint256"
        }
      ],
      "name": "getEncodedData",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_timeElapsed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_priceAdapterConfigData",
          "type": "bytes"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_priceAdapterConfigData",
          "type": "bytes"
        }
      ],
      "name": "isPriceAdapterConfigDataValid",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isValid",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x10bd255fa53aa661cb3eb34e3dde98234823fec88b662208ccf70dd2ea0081ad",
  "receipt": {
    "to": null,
    "from": "0x570f581D23a2AB09FD1990279D9DB6f5DcE18F4A",
    "contractAddress": "0xB1c27867857C095f26929E10D2Ad02718e00fCF4",
    "transactionIndex": 5,
    "gasUsed": "618734",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x955834fc90b6edb0b1d7eb91634be3af840f85dc22fdd12f5274625177b002ee",
    "transactionHash": "0x10bd255fa53aa661cb3eb34e3dde98234823fec88b662208ccf70dd2ea0081ad",
    "logs": [],
    "blockNumber": 10256202,
    "cumulativeGasUsed": "1851610",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "7fe3b69caaa6e1ae3cb624acb9fde77a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_scalingFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeCoefficient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"areParamsValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"getDecodedData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scalingFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCoefficient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDecreasing\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_scalingFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeCoefficient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bucketSize\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDecreasing\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"getEncodedData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeElapsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_priceAdapterConfigData\",\"type\":\"bytes\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_priceAdapterConfigData\",\"type\":\"bytes\"}],\"name\":\"isPriceAdapterConfigDataValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"areParamsValid(uint256,uint256,uint256,uint256,uint256,uint256)\":{\"details\":\"Returns true if the price adapter parameters are valid.\",\"params\":{\"_bucketSize\":\"Time elapsed between each bucket\",\"_initialPrice\":\"Initial price of the auction\",\"_maxPrice\":\"Maximum price of the auction\",\"_minPrice\":\"Minimum price of the auction\",\"_scalingFactor\":\"Scaling factor for logarithmic expression\",\"_timeCoefficient\":\"Scaling factor for logarithmic argument\"}},\"getDecodedData(bytes)\":{\"details\":\"Decodes the parameters from the provided bytes.\",\"params\":{\"_data\":\"Bytes encoded auction parameters\"},\"returns\":{\"bucketSize\":\"         Time elapsed between each bucket\",\"initialPrice\":\"       Initial price of the auction\",\"isDecreasing\":\"       Flag for whether the price is decreasing or increasing\",\"maxPrice\":\"           Maximum price of the auction\",\"minPrice\":\"           Minimum price of the auction\",\"scalingFactor\":\"      Scaling factor for logarithmic expression\",\"timeCoefficient\":\"    Scaling factor for logarithmic argument\"}},\"getEncodedData(uint256,uint256,uint256,uint256,bool,uint256,uint256)\":{\"details\":\"Returns the encoded data for the price curve parameters\",\"params\":{\"_bucketSize\":\"Time elapsed between each bucket\",\"_initialPrice\":\"Initial price of the auction\",\"_isDecreasing\":\"Flag for whether the price is decreasing or increasing\",\"_maxPrice\":\"Maximum price of the auction\",\"_minPrice\":\"Minimum price of the auction\",\"_scalingFactor\":\"Scaling factor for logarithmic expression\",\"_timeCoefficient\":\"Scaling factor for logarithmic argument\"}},\"getPrice(address,address,uint256,uint256,uint256,bytes)\":{\"details\":\"Calculates and returns the logarithmic price.\",\"params\":{\"_priceAdapterConfigData\":\"Encoded bytes representing the logarithmic function parameters.\",\"_timeElapsed\":\"Time elapsed since the start of the auction.\"},\"returns\":{\"price\":\"                   The price calculated using the logarithmic function.\"}},\"isPriceAdapterConfigDataValid(bytes)\":{\"details\":\"Returns true if the price adapter is valid for the given parameters.\",\"params\":{\"_priceAdapterConfigData\":\"Encoded data for configuring the price adapter.\"},\"returns\":{\"isValid\":\"                 Boolean indicating if the adapter config data is valid.\"}}},\"title\":\"BoundedStepwiseLogarithmicPriceAdapter\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that increases or decreases logarithmically in steps over time, within a bounded range. The rate of change is decreasing. Price formula: price = initialPrice +/- scalingFactor * ln(timeCoefficient * timeBucket)\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/auction-pricing/BoundedStepwiseLogarithmicPriceAdapter.sol\":\"BoundedStepwiseLogarithmicPriceAdapter\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/auction-pricing/BoundedStepwiseLogarithmicPriceAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.25;\\n\\nimport { FixedPointMathLib } from \\\"../lib/FixedPointMathLib.sol\\\";\\n\\n/**\\n * @title BoundedStepwiseLogarithmicPriceAdapter\\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\\n * increases or decreases logarithmically in steps over time, within a bounded range.\\n * The rate of change is decreasing.\\n * Price formula: price = initialPrice +/- scalingFactor * ln(timeCoefficient * timeBucket)\\n */\\ncontract BoundedStepwiseLogarithmicPriceAdapter {\\n    using FixedPointMathLib for int256;\\n\\n    int256 private constant WAD = 1e18;                   // Equivalent to PreciseUnitMath.preciseUnit()\\n    int256 private constant MAX_LOG_ARG = 2 ** 254 - 1;   // To protect against overflow when adding WAD\\n\\n    /**\\n     * @dev Calculates and returns the logarithmic price.\\n     *\\n     * @param _timeElapsed              Time elapsed since the start of the auction.\\n     * @param _priceAdapterConfigData   Encoded bytes representing the logarithmic function parameters.\\n     *\\n     * @return price                    The price calculated using the logarithmic function.\\n     */\\n    function getPrice(\\n        address /* _setToken */,\\n        address /* _component */,\\n        uint256 /* _componentQuantity */,\\n        uint256 _timeElapsed,\\n        uint256 /* _duration */,\\n        bytes memory _priceAdapterConfigData\\n    )\\n        external\\n        pure\\n        returns (uint256 price)\\n    {\\n        (\\n            uint256 initialPrice,\\n            uint256 scalingFactor,\\n            uint256 timeCoefficient,\\n            uint256 bucketSize,\\n            bool isDecreasing,\\n            uint256 maxPrice,\\n            uint256 minPrice\\n        ) = getDecodedData(_priceAdapterConfigData);\\n\\n        require(\\n            areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice),\\n            \\\"BoundedStepwiseLogarithmicPriceAdapter: Invalid params\\\"\\n        );\\n\\n        uint256 timeBucket = _timeElapsed / bucketSize;\\n\\n        // Protect against logarithmic argument overflow\\n        if (timeBucket > uint256(type(int256).max) / timeCoefficient) {\\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\\n        }\\n        int256 lnArgument = int256(timeBucket * timeCoefficient);\\n\\n        // Protect against logarithmic overflow and increasing relative error\\n        if (lnArgument > MAX_LOG_ARG) {\\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\\n        }\\n        uint256 lnExpression = uint256(FixedPointMathLib.lnWad(lnArgument + WAD));\\n\\n        // Protect against priceChange overflow\\n        if (lnExpression > type(uint256).max / scalingFactor) {\\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\\n        }\\n        uint256 priceChange = FixedPointMathLib.mulWad(scalingFactor, lnExpression);\\n\\n        if (isDecreasing) {\\n            // Protect against price underflow\\n            if (priceChange > initialPrice) {\\n                return minPrice;\\n            }\\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\\n        } else {\\n            // Protect against price overflow\\n            if (priceChange > type(uint256).max - initialPrice) {\\n                return maxPrice;\\n            }\\n            return FixedPointMathLib.min(initialPrice + priceChange, maxPrice);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the price adapter is valid for the given parameters.\\n     *\\n     * @param _priceAdapterConfigData   Encoded data for configuring the price adapter.\\n     *\\n     * @return isValid                  Boolean indicating if the adapter config data is valid.\\n     */\\n    function isPriceAdapterConfigDataValid(\\n        bytes memory _priceAdapterConfigData\\n    )\\n        external\\n        pure\\n        returns (bool isValid)\\n    {\\n        (\\n            uint256 initialPrice,\\n            uint256 scalingFactor,\\n            uint256 timeCoefficient,\\n            uint256 bucketSize,\\n            ,\\n            uint256 maxPrice,\\n            uint256 minPrice\\n        ) = getDecodedData(_priceAdapterConfigData);\\n\\n        return areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice);\\n    }\\n\\n    /**\\n     * @dev Returns true if the price adapter parameters are valid.\\n     *\\n     * @param _initialPrice      Initial price of the auction\\n     * @param _scalingFactor     Scaling factor for logarithmic expression\\n     * @param _timeCoefficient   Scaling factor for logarithmic argument\\n     * @param _bucketSize        Time elapsed between each bucket\\n     * @param _maxPrice          Maximum price of the auction\\n     * @param _minPrice          Minimum price of the auction\\n     */\\n    function areParamsValid(\\n        uint256 _initialPrice,\\n        uint256 _scalingFactor,\\n        uint256 _timeCoefficient,\\n        uint256 _bucketSize,\\n        uint256 _maxPrice,\\n        uint256 _minPrice\\n    )\\n        public\\n        pure\\n        returns (bool)\\n    {\\n        return _initialPrice > 0\\n            && _scalingFactor > 0\\n            && _timeCoefficient > 0\\n            && _bucketSize > 0\\n            && _initialPrice <= _maxPrice\\n            && _initialPrice >= _minPrice;\\n    }\\n\\n    /**\\n     * @dev Returns the encoded data for the price curve parameters\\n     *\\n     * @param _initialPrice        Initial price of the auction\\n     * @param _scalingFactor       Scaling factor for logarithmic expression\\n     * @param _timeCoefficient     Scaling factor for logarithmic argument\\n     * @param _bucketSize          Time elapsed between each bucket\\n     * @param _isDecreasing        Flag for whether the price is decreasing or increasing\\n     * @param _maxPrice            Maximum price of the auction\\n     * @param _minPrice            Minimum price of the auction\\n     */\\n    function getEncodedData(\\n        uint256 _initialPrice,\\n        uint256 _scalingFactor,\\n        uint256 _timeCoefficient,\\n        uint256 _bucketSize,\\n        bool _isDecreasing,\\n        uint256 _maxPrice,\\n        uint256 _minPrice\\n    )\\n        external\\n        pure\\n        returns (bytes memory data)\\n    {\\n        return abi.encode(_initialPrice, _scalingFactor, _timeCoefficient, _bucketSize, _isDecreasing, _maxPrice, _minPrice);\\n    }\\n\\n    /**\\n     * @dev Decodes the parameters from the provided bytes.\\n     *\\n     * @param _data                Bytes encoded auction parameters\\n     * @return initialPrice        Initial price of the auction\\n     * @return scalingFactor       Scaling factor for logarithmic expression\\n     * @return timeCoefficient     Scaling factor for logarithmic argument\\n     * @return bucketSize          Time elapsed between each bucket\\n     * @return isDecreasing        Flag for whether the price is decreasing or increasing\\n     * @return maxPrice            Maximum price of the auction\\n     * @return minPrice            Minimum price of the auction\\n     */\\n    function getDecodedData(bytes memory _data)\\n        public\\n        pure\\n        returns (uint256 initialPrice, uint256 scalingFactor, uint256 timeCoefficient, uint256 bucketSize, bool isDecreasing, uint256 maxPrice, uint256 minPrice)\\n    {\\n        return abi.decode(_data, (uint256, uint256, uint256, uint256, bool, uint256, uint256));\\n    }\\n\\n    function _getBoundaryPrice(bool isDecreasing, uint256 maxPrice, uint256 minPrice) private pure returns (uint256) {\\n        return isDecreasing ? minPrice : maxPrice;\\n    }\\n}\\n\",\"keccak256\":\"0xfb56bd4896685f8037b9722727b54dc9fd1aefc6d4837fe3949d65877b18a860\",\"license\":\"Apache-2.0\"},\"contracts/lib/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/22/exp-ln\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is less than 0.5 we return zero.\\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\\n            if (x <= -41446531673892822313) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) \\u2248 135`.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // `k` is in the range `[-61, 195]`.\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // `p` is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already `2**96` too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range `(0.09, 0.25) * 2**96`.\\n\\n            // We now need to multiply r by:\\n            // - The scale factor `s \\u2248 6.031367120`.\\n            // - The `2**k` factor from the range reduction.\\n            // - The `1e18 / 2**96` factor for base conversion.\\n            // We do this all at once, with an intermediate result in `2**213`\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256(\\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\\n            );\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/22/exp-ln\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\\n            // We do this by multiplying by `2**96 / 10**18`. But since\\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\\n            // and add `ln(2**96 / 10**18)` at the end.\\n\\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // We place the check here for more optimal stack operations.\\n            if iszero(sgt(x, 0)) {\\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // forgefmt: disable-next-item\\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x := shr(159, shl(r, x))\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // `p` is made monic, we will multiply by a scale factor later.\\n            // forgefmt: disable-next-item\\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\\n                sar(96, mul(add(43456485725739037958740375743393,\\n                sar(96, mul(add(24828157081833163892658089445524,\\n                sar(96, mul(add(3273285459638523848632254066296,\\n                    x), x))), x))), x)), 11111509109440967052023855526967)\\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\\n\\n            // `q` is monic by convention.\\n            let q := add(5573035233440673466300451813936, x)\\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\\n\\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\\n\\n            // Finalization, we need to:\\n            // - Multiply by the scale factor `s = 5.549\\u2026`.\\n            // - Add `ln(2**96 / 10**18)`.\\n            // - Add `k * ln(2)`.\\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\\n\\n            // The q polynomial is known not to have zeros in the domain.\\n            // No scaling required because p is already `2**96` too large.\\n            p := sdiv(p, q)\\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\\n            p := mul(1677202110996718588342820967067443963516166, p)\\n            // Add `ln(2) * k * 5**18 * 2**192`.\\n            // forgefmt: disable-next-item\\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\\n            // Base conversion: mul `2**18 / 2**192`.\\n            r := sar(174, p)\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x93036622f2af31d328d5c3aa7701507610024e0f9f14dc19724350c565d3fcee\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600f57600080fd5b50610a3b8061001f6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c8063079f6bf41461005c578063104b9b6414610084578063777f4126146100a5578063a45f8c07146100b8578063d3516db614610120575b600080fd5b61006f61006a366004610735565b61016a565b60405190151581526020015b60405180910390f35b610097610092366004610786565b6101a5565b60405190815260200161007b565b61006f6100b3366004610800565b6103ab565b6101136100c6366004610854565b6040805160208101989098528781019690965260608701949094526080860192909252151560a085015260c084015260e08084019190915281518084039091018152610100909201905290565b60405161007b91906108b3565b61013361012e366004610735565b6103f7565b6040805197885260208801969096529486019390935260608501919091521515608084015260a083015260c082015260e00161007b565b600080600080600080600061017e886103f7565b965096505095509550955095506101998686868686866103ab565b98975050505050505050565b6000806000806000806000806101ba896103f7565b96509650965096509650965096506101d68787878786866103ab565b6102455760405162461bcd60e51b815260206004820152603660248201527f426f756e64656453746570776973654c6f6761726974686d69635072696365416044820152756461707465723a20496e76616c696420706172616d7360501b606482015260840160405180910390fd5b6000610251858d610918565b9050610264866001600160ff1b03610918565b8111156102855761027684848461042d565b985050505050505050506103a1565b6000610291878361093a565b90506001600160fe1b038113156102bd576102ad85858561042d565b99505050505050505050506103a1565b60006102d96102d4670de0b6b3a764000084610957565b610444565b90506102e789600019610918565b81111561030a576102f986868661042d565b9a50505050505050505050506103a1565b60006103168a83610664565b90508615610363578a81111561033957849b5050505050505050505050506103a1565b610351610346828d61097f565b868110818818021890565b9b5050505050505050505050506103a1565b61036f8b60001961097f565b81111561038957859b5050505050505050505050506103a1565b610351610396828d610992565b878111818918021890565b9695505050505050565b600080871180156103bc5750600086115b80156103c85750600085115b80156103d45750600084115b80156103e05750828711155b80156103ec5750818710155b979650505050505050565b60008060008060008060008780602001905181019061041691906109a5565b959e949d50929b5090995097509550909350915050565b60008361043a578261043c565b815b949350505050565b6fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff1060061b1781811c63ffffffff1060051b1781811c61ffff1060041b1781811c60ff1060031b17600082136104a357631615e6386000526004601cfd5b7ff8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff6f8421084210842108cc6318c6db6d54be83831c1c601f161a1890811b609f90811c6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506029190037d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d90565b6000816000190483118202156106825763bac65e5b6000526004601cfd5b50670de0b6b3a764000091020490565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126106b957600080fd5b813567ffffffffffffffff808211156106d4576106d4610692565b604051601f8301601f19908116603f011681019082821181831017156106fc576106fc610692565b8160405283815286602085880101111561071557600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561074757600080fd5b813567ffffffffffffffff81111561075e57600080fd5b61043c848285016106a8565b80356001600160a01b038116811461078157600080fd5b919050565b60008060008060008060c0878903121561079f57600080fd5b6107a88761076a565b95506107b66020880161076a565b945060408701359350606087013592506080870135915060a087013567ffffffffffffffff8111156107e757600080fd5b6107f389828a016106a8565b9150509295509295509295565b60008060008060008060c0878903121561081957600080fd5b505084359660208601359650604086013595606081013595506080810135945060a0013592509050565b801515811461085157600080fd5b50565b600080600080600080600060e0888a03121561086f57600080fd5b87359650602088013595506040880135945060608801359350608088013561089681610843565b9699959850939692959460a0840135945060c09093013592915050565b60006020808352835180602085015260005b818110156108e1578581018301518582016040015282016108c5565b506000604082860101526040601f19601f8301168501019250505092915050565b634e487b7160e01b600052601160045260246000fd5b60008261093557634e487b7160e01b600052601260045260246000fd5b500490565b808202811582820484141761095157610951610902565b92915050565b808201828112600083128015821682158216171561097757610977610902565b505092915050565b8181038181111561095157610951610902565b8082018082111561095157610951610902565b600080600080600080600060e0888a0312156109c057600080fd5b8751965060208801519550604088015194506060880151935060808801516109e781610843565b8093505060a0880151915060c088015190509295989194975092955056fea2646970667358221220976a19960933fbdeb7eb61369dcb469f69f22a1a041b75df35ace9d0dbc66cc164736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c8063079f6bf41461005c578063104b9b6414610084578063777f4126146100a5578063a45f8c07146100b8578063d3516db614610120575b600080fd5b61006f61006a366004610735565b61016a565b60405190151581526020015b60405180910390f35b610097610092366004610786565b6101a5565b60405190815260200161007b565b61006f6100b3366004610800565b6103ab565b6101136100c6366004610854565b6040805160208101989098528781019690965260608701949094526080860192909252151560a085015260c084015260e08084019190915281518084039091018152610100909201905290565b60405161007b91906108b3565b61013361012e366004610735565b6103f7565b6040805197885260208801969096529486019390935260608501919091521515608084015260a083015260c082015260e00161007b565b600080600080600080600061017e886103f7565b965096505095509550955095506101998686868686866103ab565b98975050505050505050565b6000806000806000806000806101ba896103f7565b96509650965096509650965096506101d68787878786866103ab565b6102455760405162461bcd60e51b815260206004820152603660248201527f426f756e64656453746570776973654c6f6761726974686d69635072696365416044820152756461707465723a20496e76616c696420706172616d7360501b606482015260840160405180910390fd5b6000610251858d610918565b9050610264866001600160ff1b03610918565b8111156102855761027684848461042d565b985050505050505050506103a1565b6000610291878361093a565b90506001600160fe1b038113156102bd576102ad85858561042d565b99505050505050505050506103a1565b60006102d96102d4670de0b6b3a764000084610957565b610444565b90506102e789600019610918565b81111561030a576102f986868661042d565b9a50505050505050505050506103a1565b60006103168a83610664565b90508615610363578a81111561033957849b5050505050505050505050506103a1565b610351610346828d61097f565b868110818818021890565b9b5050505050505050505050506103a1565b61036f8b60001961097f565b81111561038957859b5050505050505050505050506103a1565b610351610396828d610992565b878111818918021890565b9695505050505050565b600080871180156103bc5750600086115b80156103c85750600085115b80156103d45750600084115b80156103e05750828711155b80156103ec5750818710155b979650505050505050565b60008060008060008060008780602001905181019061041691906109a5565b959e949d50929b5090995097509550909350915050565b60008361043a578261043c565b815b949350505050565b6fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff1060061b1781811c63ffffffff1060051b1781811c61ffff1060041b1781811c60ff1060031b17600082136104a357631615e6386000526004601cfd5b7ff8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff6f8421084210842108cc6318c6db6d54be83831c1c601f161a1890811b609f90811c6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506029190037d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d90565b6000816000190483118202156106825763bac65e5b6000526004601cfd5b50670de0b6b3a764000091020490565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126106b957600080fd5b813567ffffffffffffffff808211156106d4576106d4610692565b604051601f8301601f19908116603f011681019082821181831017156106fc576106fc610692565b8160405283815286602085880101111561071557600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561074757600080fd5b813567ffffffffffffffff81111561075e57600080fd5b61043c848285016106a8565b80356001600160a01b038116811461078157600080fd5b919050565b60008060008060008060c0878903121561079f57600080fd5b6107a88761076a565b95506107b66020880161076a565b945060408701359350606087013592506080870135915060a087013567ffffffffffffffff8111156107e757600080fd5b6107f389828a016106a8565b9150509295509295509295565b60008060008060008060c0878903121561081957600080fd5b505084359660208601359650604086013595606081013595506080810135945060a0013592509050565b801515811461085157600080fd5b50565b600080600080600080600060e0888a03121561086f57600080fd5b87359650602088013595506040880135945060608801359350608088013561089681610843565b9699959850939692959460a0840135945060c09093013592915050565b60006020808352835180602085015260005b818110156108e1578581018301518582016040015282016108c5565b506000604082860101526040601f19601f8301168501019250505092915050565b634e487b7160e01b600052601160045260246000fd5b60008261093557634e487b7160e01b600052601260045260246000fd5b500490565b808202811582820484141761095157610951610902565b92915050565b808201828112600083128015821682158216171561097757610977610902565b505092915050565b8181038181111561095157610951610902565b8082018082111561095157610951610902565b600080600080600080600060e0888a0312156109c057600080fd5b8751965060208801519550604088015194506060880151935060808801516109e781610843565b8093505060a0880151915060c088015190509295989194975092955056fea2646970667358221220976a19960933fbdeb7eb61369dcb469f69f22a1a041b75df35ace9d0dbc66cc164736f6c63430008190033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "areParamsValid(uint256,uint256,uint256,uint256,uint256,uint256)": {
        "details": "Returns true if the price adapter parameters are valid.",
        "params": {
          "_bucketSize": "Time elapsed between each bucket",
          "_initialPrice": "Initial price of the auction",
          "_maxPrice": "Maximum price of the auction",
          "_minPrice": "Minimum price of the auction",
          "_scalingFactor": "Scaling factor for logarithmic expression",
          "_timeCoefficient": "Scaling factor for logarithmic argument"
        }
      },
      "getDecodedData(bytes)": {
        "details": "Decodes the parameters from the provided bytes.",
        "params": {
          "_data": "Bytes encoded auction parameters"
        },
        "returns": {
          "bucketSize": "         Time elapsed between each bucket",
          "initialPrice": "       Initial price of the auction",
          "isDecreasing": "       Flag for whether the price is decreasing or increasing",
          "maxPrice": "           Maximum price of the auction",
          "minPrice": "           Minimum price of the auction",
          "scalingFactor": "      Scaling factor for logarithmic expression",
          "timeCoefficient": "    Scaling factor for logarithmic argument"
        }
      },
      "getEncodedData(uint256,uint256,uint256,uint256,bool,uint256,uint256)": {
        "details": "Returns the encoded data for the price curve parameters",
        "params": {
          "_bucketSize": "Time elapsed between each bucket",
          "_initialPrice": "Initial price of the auction",
          "_isDecreasing": "Flag for whether the price is decreasing or increasing",
          "_maxPrice": "Maximum price of the auction",
          "_minPrice": "Minimum price of the auction",
          "_scalingFactor": "Scaling factor for logarithmic expression",
          "_timeCoefficient": "Scaling factor for logarithmic argument"
        }
      },
      "getPrice(address,address,uint256,uint256,uint256,bytes)": {
        "details": "Calculates and returns the logarithmic price.",
        "params": {
          "_priceAdapterConfigData": "Encoded bytes representing the logarithmic function parameters.",
          "_timeElapsed": "Time elapsed since the start of the auction."
        },
        "returns": {
          "price": "                   The price calculated using the logarithmic function."
        }
      },
      "isPriceAdapterConfigDataValid(bytes)": {
        "details": "Returns true if the price adapter is valid for the given parameters.",
        "params": {
          "_priceAdapterConfigData": "Encoded data for configuring the price adapter."
        },
        "returns": {
          "isValid": "                 Boolean indicating if the adapter config data is valid."
        }
      }
    },
    "title": "BoundedStepwiseLogarithmicPriceAdapter",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that increases or decreases logarithmically in steps over time, within a bounded range. The rate of change is decreasing. Price formula: price = initialPrice +/- scalingFactor * ln(timeCoefficient * timeBucket)",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}