// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.26;


import "forge-std/Test.sol";
import "forge-std/console.sol";

import {IERC20} from "@openzeppelin-contracts-5/contracts/token/ERC20/IERC20.sol";
import {TokenExchangeSetIssuer} from "contracts/extensions/TokenExchangeSetIssuer.sol";
import {IIssuanceModule} from "contracts/interfaces/v0.8/IIssuanceModule.sol";
import {ISetToken} from "contracts/interfaces/v0.8/ISetToken.sol";
import {IFlokiTaxHandler} from "contracts/interfaces/v0.8/external/IFlokiTaxHandler.sol";
import {IUniswapV2Router} from "contracts/interfaces/v0.8/external/IUniswapV2Router.sol";
import {IParaswapV6} from "contracts/interfaces/v0.8/external/IParaswapV6.sol";
import {Ownable} from "@openzeppelin-contracts-5/contracts/access/Ownable.sol";

contract MockFakeExchange {
    function transferLesserQuantityThanAsked(IERC20 token, uint256 amount) external {
        token.transfer(msg.sender, amount - 1);
    }

    function noop() external {}
}

contract ForkTestTokenExchangeSetIssuer is Test {
    TokenExchangeSetIssuer tokenExchangeSetIssuer;

    address usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address dogeCoinAddress = 0x4206931337dc273a630d328dA6441786BfaD668f;
    address shibAddress = 0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE;
    address pepeAddress = 0x6982508145454Ce325dDbE47a25d4ec3d2311933;
    address flokiAddress = 0xcf0C122c6b73ff809C693DB761e7BaeBe62b6a2E;
    address wETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    address paraSwapV6Address = 0x6A000F20005980200259B80c5102003040001068;
    address basicIssuanceModuleAddress = 0x9330d0F979af5c8a5f2380f7bc41234A7d8A15de;
    address memeIndexTokenAddress = 0xA544b3F0c46c15F0B2b00ba3D67b56C250287905;
    address flokiUinswapV2pairAddress = 0xca7c2771D248dCBe09EABE0CE57A62e18dA178c0;
    address flokiTaxHandlerAddress = 0x834F96fD4fE9147a2a647D957FBbE67FEc62B67b;
    address flokiTreasuryAddress = 0xBc530Bfa3FCA1a731149248AfC7F750c18360de1;
    address uniswapRouterAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;

    IERC20 usdc = IERC20(usdcAddress);
    IERC20 doge = IERC20(dogeCoinAddress);
    IERC20 shib = IERC20(shibAddress);
    IERC20 pepe = IERC20(pepeAddress);
    IERC20 floki = IERC20(flokiAddress);
    IERC20 weth = IERC20(wETHAddress);

    IIssuanceModule issuanceModule = IIssuanceModule(basicIssuanceModuleAddress);
    ISetToken memeIndexToken = ISetToken(memeIndexTokenAddress);
    IUniswapV2Router uniswapRouter = IUniswapV2Router(uniswapRouterAddress);
    IFlokiTaxHandler flokiTaxHandler = IFlokiTaxHandler(flokiTaxHandlerAddress);

    address user = 0x92717c31E2A6C74c6Ec366bF5157563e88705205;
    address deployer = address(0x52);

    uint256 dogeUSDCAmount = uint256((3405643 * 101)) / uint256(100);
    // https://api.paraswap.io/swap?srcToken=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&destToken=0x4206931337dc273a630d328dA6441786BfaD668f&amount=2806361088&srcDecimals=6&destDecimals=8&side=BUY&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes dogeUSDCPayLoad =
        hex"7f4576750000000000000000000000005006860a0906b0d8c9c050200947000030081006000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000004206931337dc273a630d328da6441786bfad668f0000000000000000000000000000000000000000000000000000000000347c5300000000000000000000000000000000000000000000000000000000a745ac00000000000000000000000000000000000000000000000000000000000033f74b1462c2ca2b824616a80dbd290f4e52d90000000000000000000000000137039d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000001e000000160000000000000000000000120000000000000013700000000000027101b81d678ffb9c0263b24a97847620c99d213eb1401400000000000000000000000000000000000000000000000000000000000000000000000000000f28c0498000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000006a000f20005980200259b80c51020030400010680000000000000000000000000000000000000000000000000000000066ab530d00000000000000000000000000000000000000000000000000000000a745ac000000000000000000000000000000000000000000000000000000000000347c53000000000000000000000000000000000000000000000000000000000000002b4206931337dc273a630d328da6441786bfad668f0009c4a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000";
    uint256 shibUSDCAmount = uint256((3004400 * 101)) / uint256(100);
    // https://api.paraswap.io/swap?srcToken=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&destToken=0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE&amount=184275184275184265723905&srcDecimals=6&destDecimals=18&side=BUY&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes shibUSDCPayLoad =
        hex"5e94e28d0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce00000000000000000000000000000000000000000000000000000000002e4d4c00000000000000000000000000000000000000000000270593e7d6829680000100000000000000000000000000000000000000000000000000000000002dd7f093b4313a94e647929e52e39190600fa6000000000000000000000000013703a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000006000000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000000000000bb80000000000000000000000000000000000000000000000000000000000000000";

    uint256 pepeUSDCAmount = uint256((4022892 * 101)) / uint256(100);
    //https://api.paraswap.io/swap?srcToken=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&destToken=0x6982508145454Ce325dDbE47a25d4ec3d2311933&amount=332741792369121567965185&srcDecimals=6&destDecimals=18&side=BUY&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes pepeUSDCPayLoad =
        hex"5e94e28d0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000006982508145454ce325ddbe47a25d4ec3d231193300000000000000000000000000000000000000000000000000000000003dff90000000000000000000000000000000000000000000004675f7fd4224d200000100000000000000000000000000000000000000000000000000000000003d626cf1e59326739f4535b31916018d27a67a000000000000000000000000013703a20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000600000000000000000000000006982508145454ce325ddbe47a25d4ec3d2311933000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000000027100000000000000000000000000000000000000000000000000000000000000000";

    uint256 flokiUSDCAmount;
    bytes flokiUSDCPayLoad;

    uint256 wethUSDCAmount = uint256((3067449 * 101)) / uint256(100);
    // https://api.paraswap.io/swap?srcToken=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&destToken=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&amount=965424915686226&srcDecimals=6&destDecimals=18&side=BUY&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes wethUSDCPayLoad =
        hex"5e94e28d0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000002f460b00000000000000000000000000000000000000000000000000036e0c8128235200000000000000000000000000000000000000000000000000000000002ece3964866d9c8bbb420fa194d74e03dfbee9000000000000000000000000013703a9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000060800000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000000";

    uint256 dogeWETHAmount = uint256((1108411581623423 * 101)) / uint256(100);
    // https://api.paraswap.io/swap?srcToken=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&destToken=0x4206931337dc273a630d328dA6441786BfaD668f&amount=2806361088&srcDecimals=18&destDecimals=8&side=BUY&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes dogeWETHPayLoad =
        hex"a76f4eb60000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000004206931337dc273a630d328da6441786bfad668f0000000000000000000000000000000000000000000000000003fa2ce75f9ba900000000000000000000000000000000000000000000000000000000a745ac000000000000000000000000000000000000000000000000000003f0182e966c7fd9bfc12a9ce34e04ae626746b384b66e00000000000000000000000001370cd90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000404206931337dc273a630d328da6441786bfad668fc02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    uint256 shibWETHAmount = uint256((951668730580914 * 101)) / uint256(100);
    // https://api.paraswap.io/swap?srcToken=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&destToken=0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE&amount=184275184275184265723905&srcDecimals=18&destDecimals=18&side=BUY&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes shibWETHPayLoad =
        hex"5e94e28d0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce00000000000000000000000000000000000000000000000000036a316b657c0300000000000000000000000000000000000000000000270593e7d6829680000100000000000000000000000000000000000000000000000000036189a4a14fb2129fa3a6e6894388a817d49979fa1e9300000000000000000000000001370ce100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000006000000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000000";

    uint256 pepeWETHAmount = uint256((1237056916517651 * 101)) / uint256(100);
    // https://api.paraswap.io/swap?srcToken=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&destToken=0x6982508145454Ce325dDbE47a25d4ec3d2311933&amount=332741792369121567965185&srcDecimals=18&destDecimals=18&side=BUY&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes pepeWETHPayLoad =
        hex"5e94e28d0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000006982508145454ce325ddbe47a25d4ec3d2311933000000000000000000000000000000000000000000000000000470590174ec8b000000000000000000000000000000000000000000004675f7fd4224d200000100000000000000000000000000000000000000000000000000046518c2137313e78e9fef30374ff0b173832fb2e2e78100000000000000000000000001370ce70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000600000000000000000000000006982508145454ce325ddbe47a25d4ec3d2311933000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000bb80000000000000000000000000000000000000000000000000000000000000000";

    uint256 flokiWETHAmount;
    bytes flokiWETHPayLoad;

    uint256 wethWETHAmount = 965424915686226;
    bytes wethWETHPayLoad;

    // https://api.paraswap.io/swap?srcToken=0x4206931337dc273a630d328dA6441786BfaD668f&destToken=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&amount=2806361087&srcDecimals=8&destDecimals=6&side=SELL&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes sellDogeUSDCPayLoad =
        hex"e3ead59e0000000000000000000000005f0000d4780a00d2dce0a00004000800cb0e50410000000000000000000000004206931337dc273a630d328da6441786bfad668f000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000028d6827da2300000000000000000000000000000000000000000000000000000000d11603aa00000000000000000000000000000000000000000000000000000000d332ae5ee88315512aba4f4c98c60c230b5f594c000000000000000000000000013717a30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002e0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000002e04206931337dc273a630d328da6441786bfad668f0000006000240000ff00000300000000000000000000000000000000000000000000000000000000a9059cbb000000000000000000000000c0067d751fb1172dbab1fa003efe214ee8f419b60000000000000000000000000000000000000000000000000000028d6827da235f0000d4780a00d2dce0a00004000800cb0e5041000000a000240064ff06000b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000028d6827da23000000000000000000004de4c0067d751fb1172dbab1fa003efe214ee8f419b6000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2e592427a0aece92de3edee1f18e0157c0586156400000140008400000000000300000000000000000000000000000000000000000000000000000000c04b8d59000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000006a000f20005980200259b80c51020030400010680000000000000000000000000000000000000000000000000000000066ac44eb0000000000000000000000000000000000000000000000000f36c2e482a999f90000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002bc02aaa39b223fe8d0a0e5c4f27ead9083c756cc20001f4a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000";
    // https://api.paraswap.io/swap?srcToken=0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE&destToken=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&amount=184275184275184265723904&srcDecimals=18&destDecimals=6&side=SELL&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes sellShibUSDCPayLoad =
        hex"e3ead59e0000000000000000000000005f0000d4780a00d2dce0a00004000800cb0e504100000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000986dc9c19dee1be3ffffff00000000000000000000000000000000000000000000000000000000b62c255d00000000000000000000000000000000000000000000000000000000b80337d76f52b681f8ab42fe9d206813f039d1d5000000000000000000000000013717a30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002e0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000002e095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce0000006000240000ff00000300000000000000000000000000000000000000000000000000000000a9059cbb000000000000000000000000cf6daab95c476106eca715d48de4b13287ffdeaa000000000000000000000000000000000000000000986dc9c19dee1be3ffffff5f0000d4780a00d2dce0a00004000800cb0e5041000000a000240064ff06000b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000986dc9c19dee1be3ffffff000000000000000000004de4cf6daab95c476106eca715d48de4b13287ffdeaa000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2e592427a0aece92de3edee1f18e0157c0586156400000140008400000000000300000000000000000000000000000000000000000000000000000000c04b8d59000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000006a000f20005980200259b80c51020030400010680000000000000000000000000000000000000000000000000000000066ac44e80000000000000000000000000000000000000000000000000d416c4e0bb86b680000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002bc02aaa39b223fe8d0a0e5c4f27ead9083c756cc20001f4a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000";

    // https://api.paraswap.io/swap?srcToken=0x6982508145454Ce325dDbE47a25d4ec3d2311933&destToken=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&amount=332741792369121567965184&srcDecimals=18&destDecimals=6&side=SELL&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes sellPepeUSDCPayLoad =
        hex"e3ead59e0000000000000000000000005f0000d4780a00d2dce0a00004000800cb0e50410000000000000000000000006982508145454ce325ddbe47a25d4ec3d2311933000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000001133cd0b54a5fd44fffffff00000000000000000000000000000000000000000000000000000000e8dacd1500000000000000000000000000000000000000000000000000000000eb34ee2ff66fe59ef6bf4009a3503cfd38110b24000000000000000000000000013717a30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002e0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000002e06982508145454ce325ddbe47a25d4ec3d23119330000006000240000ff00000300000000000000000000000000000000000000000000000000000000a9059cbb000000000000000000000000a43fe16908251ee70ef74718545e4fe6c5ccec9f000000000000000000000000000000000000000001133cd0b54a5fd44fffffff5f0000d4780a00d2dce0a00004000800cb0e5041000000a000240064ff06000b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000001133cd0b54a5fd44fffffff000000000000000000004de4a43fe16908251ee70ef74718545e4fe6c5ccec9f000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2e592427a0aece92de3edee1f18e0157c0586156400000140008400000000000300000000000000000000000000000000000000000000000000000000c04b8d59000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000006a000f20005980200259b80c51020030400010680000000000000000000000000000000000000000000000000000000066ac44e500000000000000000000000000000000000000000000000010f184eda7200d630000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002bc02aaa39b223fe8d0a0e5c4f27ead9083c756cc20001f4a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000";

    // https://api.paraswap.io/swap?srcToken=0xcf0C122c6b73ff809C693DB761e7BaeBe62b6a2E&destToken=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&amount=20746887966806&srcDecimals=9&destDecimals=6&side=SELL&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=250&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes sellFlokiUSDCPayLoad;

    // https://api.paraswap.io/swap?srcToken=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&destToken=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&amount=965424915686225&srcDecimals=18&destDecimals=6&side=SELL&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes sellWethUSDCPayLoad =
        hex"876a02f6000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000240000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000d65e0d884c9f27300000000000000000000000000000000000000000000000000000000b810b6f000000000000000000000000000000000000000000000000000000000b9ecae7190fbfb02b1c64338ac3105a319acf5d6000000000000000000000000013717a20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000c0800000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000000000000000000000000000000000000000064000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000000";

    // https://api.paraswap.io/swap?srcToken=0x4206931337dc273a630d328dA6441786BfaD668f&destToken=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&amount=3180542565&srcDecimals=8&destDecimals=18&side=SELL&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes sellDogeWETHPayLoad =
        hex"e8bb3b6c0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000004206931337dc273a630d328da6441786bfad668f000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000bd933a6400000000000000000000000000000000000000000000000000044b5fc1e1c44c0000000000000000000000000000000000000000000000000004567a954b7b4a7a8456f47cfb4c93a739d93e1759732200000000000000000000000001397d7d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000404206931337dc273a630d328da6441786bfad668fc02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000";
    // https://api.paraswap.io/swap?srcToken=0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE&destToken=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&amount=208845208845208834487092&srcDecimals=18&destDecimals=18&side=SELL&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes sellShibWETHPayLoad =
        hex"876a02f60000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000002c39857e3760ccb333330000000000000000000000000000000000000000000000000003bdd088847c740000000000000000000000000000000000000000000000000003c77d4e6bf73e6ed7ae583cc344c2bd4e69be8cac832300000000000000000000000001397d7d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000006080000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000000";
    // https://api.paraswap.io/swap?srcToken=0x6982508145454Ce325dDbE47a25d4ec3d2311933&destToken=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&amount=377107364685004443693876&srcDecimals=18&destDecimals=18&side=SELL&network=1&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2&slippage=100&userAddress=0x1473cCdC135f1D365511028bf0e103B959cbceB5
    bytes sellPepeWETHPayLoad =
        hex"876a02f60000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000006982508145454ce325ddbe47a25d4ec3d2311933000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000004fdb07fce490213333330000000000000000000000000000000000000000000000000003a603bec3e41a0000000000000000000000000000000000000000000000000003af72f994bd086505a7ffac2a4b97a561006986a55c0400000000000000000000000001397d7d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000608000000000000000000000006982508145454ce325ddbe47a25d4ec3d2311933000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000bb80000000000000000000000000000000000000000000000000000000000000000";

    bytes sellFlokiWETHPayLoad;
    bytes sellWethWETHPayLoad;

    function setUp() external {
        vm.startPrank(deployer);
        tokenExchangeSetIssuer = new TokenExchangeSetIssuer(deployer);

        IERC20[] memory tokens = new IERC20[](6);
        tokens[0] = usdc;
        tokens[1] = weth;
        tokens[2] = doge;
        tokens[3] = shib;
        tokens[4] = pepe;
        tokens[5] = floki;
        tokenExchangeSetIssuer.approveTokens(tokens, paraSwapV6Address, type(uint256).max);
        tokenExchangeSetIssuer.approveTokens(tokens, uniswapRouterAddress, type(uint256).max);
        tokenExchangeSetIssuer.approveTokens(tokens, basicIssuanceModuleAddress, type(uint256).max);

        tokenExchangeSetIssuer.addSetTokenIssuanceModules(memeIndexTokenAddress, basicIssuanceModuleAddress);

        bytes4[] memory paraswapSelectors = new bytes4[](6);
        paraswapSelectors[0] = bytes4(IParaswapV6.swapExactAmountOut.selector);
        paraswapSelectors[1] = bytes4(IParaswapV6.swapExactAmountOutOnUniswapV3.selector);
        paraswapSelectors[2] = bytes4(IParaswapV6.swapExactAmountOutOnUniswapV2.selector);
        paraswapSelectors[3] = bytes4(IParaswapV6.swapExactAmountIn.selector);
        paraswapSelectors[4] = bytes4(IParaswapV6.swapExactAmountInOnUniswapV3.selector);
        paraswapSelectors[5] = bytes4(IParaswapV6.swapExactAmountInOnUniswapV2.selector);
        tokenExchangeSetIssuer.whitelistFunctions(paraSwapV6Address, paraswapSelectors);

        bytes4[] memory uniswapSelectors = new bytes4[](2);
        uniswapSelectors[0] = uniswapRouter.swapTokensForExactTokens.selector;
        uniswapSelectors[1] = uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens.selector;
        tokenExchangeSetIssuer.whitelistFunctions(uniswapRouterAddress, uniswapSelectors);

        deal({token: usdcAddress, to: user, give: 10000e6});
        deal({token: wETHAddress, to: user, give: 10000e18});

        vm.makePersistent(user);
        vm.makePersistent(usdcAddress);
        vm.makePersistent(dogeCoinAddress);
        vm.makePersistent(shibAddress);
        vm.makePersistent(pepeAddress);
        vm.makePersistent(flokiAddress);
        vm.makePersistent(wETHAddress);
        vm.makePersistent(paraSwapV6Address);
        vm.makePersistent(memeIndexTokenAddress);
        vm.makePersistent(address(tokenExchangeSetIssuer));
        vm.makePersistent(uniswapRouterAddress);
        vm.makePersistent(flokiUinswapV2pairAddress);
        vm.makePersistent(flokiTaxHandlerAddress);
        vm.makePersistent(flokiTreasuryAddress);
        vm.stopPrank();
    }

    function testIssueTokensWithUSDC() external {
        vm.rollFork(20382626);
        vm.startPrank(user);
        (flokiUSDCAmount, flokiUSDCPayLoad) = _computeFlokiBuyData(20746887966806, usdcAddress);
        uint256 totalQuote = dogeUSDCAmount + shibUSDCAmount + pepeUSDCAmount + flokiUSDCAmount + wethUSDCAmount;

        uint256 oldDogeBalance = doge.balanceOf(memeIndexTokenAddress);
        uint256 oldShibBalance = shib.balanceOf(memeIndexTokenAddress);
        uint256 oldPepeBalance = pepe.balanceOf(memeIndexTokenAddress);
        uint256 oldFlokiBalance = floki.balanceOf(memeIndexTokenAddress);
        uint256 oldWethiBalance = weth.balanceOf(memeIndexTokenAddress);

        usdc.approve(address(tokenExchangeSetIssuer), totalQuote);
        uint256 memeIndexQuantity = 1.5 ether;
        bytes[] memory payLoads = new bytes[](5);
        payLoads[0] = dogeUSDCPayLoad;
        payLoads[1] = shibUSDCPayLoad;
        payLoads[2] = pepeUSDCPayLoad;
        payLoads[3] = flokiUSDCPayLoad;
        payLoads[4] = wethUSDCPayLoad;
        address[] memory exchanges = new address[](5);
        exchanges[0] = paraSwapV6Address;
        exchanges[1] = paraSwapV6Address;
        exchanges[2] = paraSwapV6Address;
        exchanges[3] = uniswapRouterAddress;
        exchanges[4] = paraSwapV6Address;
        tokenExchangeSetIssuer.buyComponentsAndIssueSetToken(
            memeIndexToken,
            memeIndexQuantity,
            usdc,
            totalQuote,
            exchanges,
            payLoads
        );

        uint256 newDogeBalance = doge.balanceOf(memeIndexTokenAddress);
        uint256 newShibBalance = shib.balanceOf(memeIndexTokenAddress);
        uint256 newPepeBalance = pepe.balanceOf(memeIndexTokenAddress);
        uint256 newFlokiBalance = floki.balanceOf(memeIndexTokenAddress);
        uint256 newWethiBalance = weth.balanceOf(memeIndexTokenAddress);
        assertGt(newDogeBalance, oldDogeBalance);
        assertGt(newShibBalance, oldShibBalance);
        assertGt(newPepeBalance, oldPepeBalance);
        assertGt(newFlokiBalance, oldFlokiBalance);
        assertGt(newWethiBalance, oldWethiBalance);
        assertEq(usdc.balanceOf(address(tokenExchangeSetIssuer)), 0);
        assertEq(memeIndexToken.balanceOf(user), memeIndexQuantity);
    }

    function testIssueTokensWithWETH() external {
        vm.rollFork(20385003);
        vm.startPrank(user);

        (flokiWETHAmount, flokiWETHPayLoad) = _computeFlokiBuyData(20746887966806, wETHAddress);
        uint256 totalQuote = dogeWETHAmount + shibWETHAmount + pepeWETHAmount + flokiWETHAmount + wethWETHAmount;

        uint256 oldDogeBalance = doge.balanceOf(memeIndexTokenAddress);
        uint256 oldShibBalance = shib.balanceOf(memeIndexTokenAddress);
        uint256 oldPepeBalance = pepe.balanceOf(memeIndexTokenAddress);
        uint256 oldFlokiBalance = floki.balanceOf(memeIndexTokenAddress);
        uint256 oldWethiBalance = weth.balanceOf(memeIndexTokenAddress);

        weth.approve(address(tokenExchangeSetIssuer), totalQuote);
        uint256 memeIndexQuantity = 1.5 ether;
        bytes[] memory payLoads = new bytes[](5);
        payLoads[0] = dogeWETHPayLoad;
        payLoads[1] = shibWETHPayLoad;
        payLoads[2] = pepeWETHPayLoad;
        payLoads[3] = flokiWETHPayLoad;
        payLoads[4] = wethWETHPayLoad;
        address[] memory exchanges = new address[](5);
        exchanges[0] = paraSwapV6Address;
        exchanges[1] = paraSwapV6Address;
        exchanges[2] = paraSwapV6Address;
        exchanges[3] = uniswapRouterAddress;
        exchanges[4] = paraSwapV6Address;
        tokenExchangeSetIssuer.buyComponentsAndIssueSetToken(
            memeIndexToken,
            memeIndexQuantity,
            weth,
            totalQuote,
            exchanges,
            payLoads
        );

        uint256 newDogeBalance = doge.balanceOf(memeIndexTokenAddress);
        uint256 newShibBalance = shib.balanceOf(memeIndexTokenAddress);
        uint256 newPepeBalance = pepe.balanceOf(memeIndexTokenAddress);
        uint256 newFlokiBalance = floki.balanceOf(memeIndexTokenAddress);
        uint256 newWethiBalance = weth.balanceOf(memeIndexTokenAddress);
        assertGt(newDogeBalance, oldDogeBalance);
        assertGt(newShibBalance, oldShibBalance);
        assertGt(newPepeBalance, oldPepeBalance);
        assertGt(newFlokiBalance, oldFlokiBalance);
        assertGt(newWethiBalance, oldWethiBalance);
        assertEq(weth.balanceOf(address(tokenExchangeSetIssuer)), 0);
        assertEq(memeIndexToken.balanceOf(user), memeIndexQuantity);
    }

    function _computeFlokiBuyData(
        uint256 amountOut,
        address quoteAsset
    ) private view returns (uint256 amountIn, bytes memory payload) {
        address[] memory path;
        if (quoteAsset == usdcAddress) {
            path = new address[](3);
            path[0] = usdcAddress;
            path[1] = wETHAddress;
            path[2] = flokiAddress;
        } else if (quoteAsset == wETHAddress) {
            path = new address[](2);
            path[0] = wETHAddress;
            path[1] = flokiAddress;
        } else {
            revert("QuoteAsset not supported");
        }
        uint256 tax = flokiTaxHandler.getTax(flokiUinswapV2pairAddress, user, amountOut);
        uint256 adjustedAmountOut = (amountOut * amountOut) / (amountOut - tax);
        amountIn = (uniswapRouter.getAmountsIn(adjustedAmountOut, path)[0] * 11) / 10;
        payload = abi.encodeWithSelector(
            uniswapRouter.swapTokensForExactTokens.selector,
            adjustedAmountOut,
            amountIn,
            path,
            address(tokenExchangeSetIssuer),
            block.timestamp + 3 * 60 * 60
        );
    }

    function _computeFlokiSellData(
        uint256 amountIn,
        uint256 amountOutMin,
        address quoteAsset
    ) private view returns (bytes memory payload) {
        address[] memory path;
        if (quoteAsset == usdcAddress) {
            path = new address[](3);
            path[0] = flokiAddress;
            path[1] = wETHAddress;
            path[2] = usdcAddress;
        } else if (quoteAsset == wETHAddress) {
            path = new address[](2);
            path[0] = flokiAddress;
            path[1] = wETHAddress;
        } else {
            revert("QuoteAsset not supported");
        }
        payload = abi.encodeWithSelector(
            uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens.selector,
            amountIn,
            amountOutMin,
            path,
            address(tokenExchangeSetIssuer),
            block.timestamp + 3 * 60 * 60
        );
    }

    function _issueMeme(uint256 memeIndexQuantity) internal {
        (address[] memory components, uint256[] memory componentQuantities) = issuanceModule
            .getRequiredComponentUnitsForIssue(memeIndexToken, memeIndexQuantity);
        for (uint i = 0; i < components.length; i++) {
            deal({token: components[i], to: user, give: componentQuantities[i]});
            IERC20(components[i]).approve(basicIssuanceModuleAddress, componentQuantities[i]);
        }
        issuanceModule.issue(memeIndexToken, memeIndexQuantity, user);
    }

    function testRedeemForUSDC() external {
        vm.rollFork(20387746);
        vm.startPrank(user);
        uint256 memeIndexQuantity = 1500 ether;
        _issueMeme(memeIndexQuantity);
        uint256 expectedUSDCAfterSelling = 17358121715;
        uint256 expectedUSDCSellingFloki = 3673297867;
        uint256 flokiAmount = 20746887966805499;

        bytes[] memory payLoads = new bytes[](5);
        payLoads[0] = sellDogeUSDCPayLoad;
        payLoads[1] = sellShibUSDCPayLoad;
        payLoads[2] = sellPepeUSDCPayLoad;
        payLoads[3] = _computeFlokiSellData(flokiAmount, expectedUSDCSellingFloki, usdcAddress);
        payLoads[4] = sellWethUSDCPayLoad;
        address[] memory exchanges = new address[](5);
        exchanges[0] = paraSwapV6Address;
        exchanges[1] = paraSwapV6Address;
        exchanges[2] = paraSwapV6Address;
        exchanges[3] = uniswapRouterAddress;
        exchanges[4] = paraSwapV6Address;

        uint256 oldBalance = usdc.balanceOf(user);

        memeIndexToken.approve(address(tokenExchangeSetIssuer), memeIndexQuantity);
        tokenExchangeSetIssuer.redeemSetTokenAndExchangeTokens(
            memeIndexToken,
            memeIndexQuantity,
            usdc,
            expectedUSDCAfterSelling,
            exchanges,
            payLoads
        );
        uint256 afterBalance = usdc.balanceOf(user);
        assertEq(afterBalance - oldBalance, expectedUSDCAfterSelling);
    }

    function testRedeemForWETH() external {
        vm.rollFork(20544893);
        vm.startPrank(user);
        uint256 memeIndexQuantity = 1.7 ether;
        _issueMeme(memeIndexQuantity);
        uint256 flokiAmount = 23513139695712;

        bytes[] memory payLoads = new bytes[](5);
        payLoads[0] = sellDogeWETHPayLoad;
        payLoads[1] = sellShibWETHPayLoad;
        payLoads[2] = sellPepeWETHPayLoad;
        payLoads[3] = _computeFlokiSellData(flokiAmount, 0, wETHAddress);
        payLoads[4] = sellWethWETHPayLoad;
        address[] memory exchanges = new address[](5);
        exchanges[0] = paraSwapV6Address;
        exchanges[1] = paraSwapV6Address;
        exchanges[2] = paraSwapV6Address;
        exchanges[3] = uniswapRouterAddress;
        exchanges[4] = paraSwapV6Address;
        memeIndexToken.approve(address(tokenExchangeSetIssuer), memeIndexQuantity);
        tokenExchangeSetIssuer.redeemSetTokenAndExchangeTokens(
            memeIndexToken,
            memeIndexQuantity,
            weth,
            0,
            exchanges,
            payLoads
        );
    }

    function testErrorForBuySetQuantityZero() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        vm.expectRevert(TokenExchangeSetIssuer.SetQuantityCannotBeZero.selector);
        tokenExchangeSetIssuer.buyComponentsAndIssueSetToken(memeIndexToken, 0, weth, 1, exchanges, payLoads);
    }

    function testErrorForBuyQuoteAmountZero() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        vm.expectRevert(TokenExchangeSetIssuer.QuoteAmountCannotBeZero.selector);
        tokenExchangeSetIssuer.buyComponentsAndIssueSetToken(memeIndexToken, 1, weth, 0, exchanges, payLoads);
    }

    function testErrorForRedeemSetQuantityZero() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        vm.expectRevert(TokenExchangeSetIssuer.SetQuantityCannotBeZero.selector);
        tokenExchangeSetIssuer.redeemSetTokenAndExchangeTokens(memeIndexToken, 0, weth, 1, exchanges, payLoads);
    }

    function testErrorForBuyWhenInvalidSetToken() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        vm.startPrank(user);
        weth.approve(address(tokenExchangeSetIssuer), 1);
        vm.expectRevert(TokenExchangeSetIssuer.SetTokenNotWhitelisted.selector);
        tokenExchangeSetIssuer.buyComponentsAndIssueSetToken(ISetToken(address(0x01)), 1, weth, 1, exchanges, payLoads);
    }

    function testErrorForRedeemWhenInvalidSetToken() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        vm.prank(deployer);
        tokenExchangeSetIssuer.removeSetTokenIssuanceModules(address(memeIndexToken));
        vm.startPrank(user);
        _issueMeme(1);
        memeIndexToken.approve(address(tokenExchangeSetIssuer), 1);
        vm.expectRevert(TokenExchangeSetIssuer.SetTokenNotWhitelisted.selector);
        tokenExchangeSetIssuer.redeemSetTokenAndExchangeTokens(memeIndexToken, 1, weth, 1, exchanges, payLoads);
    }

    function testErrorForBuyWhenInvalidExchange() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        payLoads[0] = hex"7f457675";
        vm.startPrank(user);
        weth.approve(address(tokenExchangeSetIssuer), 1);
        vm.expectRevert(TokenExchangeSetIssuer.FunctionNotWhitelisted.selector);
        tokenExchangeSetIssuer.buyComponentsAndIssueSetToken(memeIndexToken, 1, weth, 1, exchanges, payLoads);
    }

    function testErrorForRedeemWhenInvalidExchange() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        payLoads[0] = hex"7f457675";
        vm.startPrank(user);
        _issueMeme(1);
        memeIndexToken.approve(address(tokenExchangeSetIssuer), 1);
        vm.expectRevert(TokenExchangeSetIssuer.FunctionNotWhitelisted.selector);
        tokenExchangeSetIssuer.redeemSetTokenAndExchangeTokens(memeIndexToken, 1, weth, 1, exchanges, payLoads);
    }

    function testErrorForBuyWhenExchangeCallFail() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        exchanges[0] = paraSwapV6Address;
        payLoads[0] = hex"7f457675";
        vm.startPrank(user);
        weth.approve(address(tokenExchangeSetIssuer), 1);
        vm.expectRevert(TokenExchangeSetIssuer.ExchangeCallFailed.selector);
        tokenExchangeSetIssuer.buyComponentsAndIssueSetToken(memeIndexToken, 1, weth, 1, exchanges, payLoads);
    }

    function testErrorForRedeemWhenExchangeCallFail() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        exchanges[0] = paraSwapV6Address;
        payLoads[0] = hex"7f457675";
        vm.startPrank(user);
        _issueMeme(1);
        memeIndexToken.approve(address(tokenExchangeSetIssuer), 1);
        vm.expectRevert(TokenExchangeSetIssuer.ExchangeCallFailed.selector);
        tokenExchangeSetIssuer.redeemSetTokenAndExchangeTokens(memeIndexToken, 1, weth, 1, exchanges, payLoads);
    }

    function testErrorInvalidPayloadWhenBuying() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        exchanges[0] = paraSwapV6Address;
        vm.startPrank(user);
        weth.approve(address(tokenExchangeSetIssuer), 1);
        vm.expectRevert(TokenExchangeSetIssuer.InvalidPayload.selector);
        tokenExchangeSetIssuer.buyComponentsAndIssueSetToken(memeIndexToken, 1, weth, 1, exchanges, payLoads);
    }

    function testErrorInvalidPayloadWhenSelling() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        exchanges[0] = paraSwapV6Address;
        vm.startPrank(user);
        _issueMeme(1);
        memeIndexToken.approve(address(tokenExchangeSetIssuer), 1);
        vm.expectRevert(TokenExchangeSetIssuer.InvalidPayload.selector);
        tokenExchangeSetIssuer.redeemSetTokenAndExchangeTokens(memeIndexToken, 1, weth, 1, exchanges, payLoads);
    }

    function testErrorForBuyWhenComponentBoughtIsLess() external {
        MockFakeExchange fakeExchange = new MockFakeExchange();
        deal({token: dogeCoinAddress, to: address(fakeExchange), give: 1000e8});
        vm.prank(deployer);
        bytes4[] memory selectors = new bytes4[](1);
        selectors[0] = fakeExchange.transferLesserQuantityThanAsked.selector;
        tokenExchangeSetIssuer.whitelistFunctions(address(fakeExchange), selectors);
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        exchanges[0] = address(fakeExchange);
        payLoads[0] = abi.encodeWithSelector(fakeExchange.transferLesserQuantityThanAsked.selector, doge, 2);
        vm.startPrank(user);
        weth.approve(address(tokenExchangeSetIssuer), 1 ether);
        vm.expectRevert(TokenExchangeSetIssuer.QuantityBoughtLessThanMinimum.selector);
        tokenExchangeSetIssuer.buyComponentsAndIssueSetToken(
            memeIndexToken,
            1.5 ether,
            weth,
            1 ether,
            exchanges,
            payLoads
        );
    }

    function testErrorForRedeemWhenMinAmountOutIsLess() external {
        MockFakeExchange fakeExchange = new MockFakeExchange();
        vm.prank(deployer);
        bytes4[] memory selectors = new bytes4[](1);
        selectors[0] = fakeExchange.noop.selector;
        tokenExchangeSetIssuer.whitelistFunctions(address(fakeExchange), selectors);
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](5);
        bytes memory payload = abi.encodeWithSelector(fakeExchange.noop.selector);
        exchanges[0] = address(fakeExchange);
        payLoads[0] = payload;
        exchanges[1] = address(fakeExchange);
        payLoads[1] = payload;
        exchanges[2] = address(fakeExchange);
        payLoads[2] = payload;
        exchanges[3] = address(fakeExchange);
        payLoads[3] = payload;
        exchanges[4] = address(fakeExchange);
        payLoads[4] = payload;
        vm.startPrank(user);
        weth.approve(address(tokenExchangeSetIssuer), 1 ether);
        _issueMeme(1.5 ether);
        memeIndexToken.approve(address(tokenExchangeSetIssuer), 1.5 ether);
        vm.expectRevert(TokenExchangeSetIssuer.ReceivedAmountLessThanExpected.selector);
        tokenExchangeSetIssuer.redeemSetTokenAndExchangeTokens(
            memeIndexToken,
            1.5 ether,
            weth,
            1 ether,
            exchanges,
            payLoads
        );
    }

    function testErrorForBuyWhenExchangesLessThanComponents() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](2);
        vm.startPrank(user);
        weth.approve(address(tokenExchangeSetIssuer), 1 ether);
        vm.expectRevert(TokenExchangeSetIssuer.ExchangeLengthMismatch.selector);
        tokenExchangeSetIssuer.buyComponentsAndIssueSetToken(
            memeIndexToken,
            1.5 ether,
            weth,
            1 ether,
            exchanges,
            payLoads
        );
    }

    function testErrorForBuyWhenPayloadLessThanComponents() external {
        bytes[] memory payLoads = new bytes[](2);
        address[] memory exchanges = new address[](5);
        vm.startPrank(user);
        weth.approve(address(tokenExchangeSetIssuer), 1 ether);
        vm.expectRevert(TokenExchangeSetIssuer.PayloadLengthMismatch.selector);
        tokenExchangeSetIssuer.buyComponentsAndIssueSetToken(
            memeIndexToken,
            1.5 ether,
            weth,
            1 ether,
            exchanges,
            payLoads
        );
    }

    function testErrorForRedeemWhenExchangesLessThanComponents() external {
        bytes[] memory payLoads = new bytes[](5);
        address[] memory exchanges = new address[](2);
        vm.startPrank(user);
        _issueMeme(1.5 ether);
        memeIndexToken.approve(address(tokenExchangeSetIssuer), 1.5 ether);
        vm.expectRevert(TokenExchangeSetIssuer.ExchangeLengthMismatch.selector);
        tokenExchangeSetIssuer.redeemSetTokenAndExchangeTokens(
            memeIndexToken,
            1.5 ether,
            weth,
            1 ether,
            exchanges,
            payLoads
        );
    }

    function testErrorForRedeemWhenPayloadLessThanComponents() external {
        bytes[] memory payLoads = new bytes[](2);
        address[] memory exchanges = new address[](5);
        vm.startPrank(user);
        _issueMeme(1.5 ether);
        memeIndexToken.approve(address(tokenExchangeSetIssuer), 1.5 ether);
        vm.expectRevert(TokenExchangeSetIssuer.PayloadLengthMismatch.selector);
        tokenExchangeSetIssuer.redeemSetTokenAndExchangeTokens(
            memeIndexToken,
            1.5 ether,
            weth,
            1 ether,
            exchanges,
            payLoads
        );
    }

    function testErrorAddZeroSetToken() external {
        vm.startPrank(deployer);
        vm.expectRevert(TokenExchangeSetIssuer.SetAddressCannotBeZero.selector);
        tokenExchangeSetIssuer.addSetTokenIssuanceModules(address(0), address(0x1));
    }

    function testErrorAddSetTokenZeroIssuance() external {
        vm.startPrank(deployer);
        vm.expectRevert(TokenExchangeSetIssuer.IssuanceAddressCannotBeZero.selector);
        tokenExchangeSetIssuer.addSetTokenIssuanceModules(address(0x1), address(0));
    }

    function testErrorAddSetTokenWhenNotAdmin() external {
        vm.expectRevert(
            abi.encodeWithSelector(Ownable.OwnableUnauthorizedAccount.selector, address(this))
        );
        tokenExchangeSetIssuer.addSetTokenIssuanceModules(address(0x1), address(0x02));
    }

    function testErrorApproveTokensWhenNotAdmin() external {
        IERC20[] memory tokens;
        vm.expectRevert(
            abi.encodeWithSelector(Ownable.OwnableUnauthorizedAccount.selector, address(this))
        );
        tokenExchangeSetIssuer.approveTokens(tokens, address(0x02), type(uint256).max);
    }

    function testErrorRemoveSetTokenWhenNotAdmin() external {
        vm.expectRevert(
            abi.encodeWithSelector(Ownable.OwnableUnauthorizedAccount.selector, address(this))
        );
        tokenExchangeSetIssuer.removeSetTokenIssuanceModules(address(0x1));
    }

    function testErrorWhitelistFunctionWhenNotAdmin() external {
        vm.expectRevert(
            abi.encodeWithSelector(Ownable.OwnableUnauthorizedAccount.selector, address(this))
        );
        bytes4[] memory selectors = new bytes4[](1);
        tokenExchangeSetIssuer.whitelistFunctions(address(0x1), selectors);
    }

    function testErrorRevokeWhitelistFunctionWhenNotAdmin() external {
        vm.expectRevert(
            abi.encodeWithSelector(Ownable.OwnableUnauthorizedAccount.selector, address(this))
        );
        bytes4[] memory selectors = new bytes4[](1);
        tokenExchangeSetIssuer.revokeWhitelistedFunctions(address(0x1), selectors);
    }

    function testErrorZeroAddressWhitelistFunction() external {
        vm.startPrank(deployer);
        vm.expectRevert(TokenExchangeSetIssuer.TargetAddressCannotBeZero.selector);
        bytes4[] memory selectors = new bytes4[](1);
        tokenExchangeSetIssuer.whitelistFunctions(address(0), selectors);
    }

    function testErrorRevokeNonWhiteListedFunction() external {
        vm.startPrank(deployer);
        vm.expectRevert(TokenExchangeSetIssuer.FunctionNotWhitelisted.selector);
        bytes4[] memory selectors = new bytes4[](1);
        tokenExchangeSetIssuer.revokeWhitelistedFunctions(uniswapRouterAddress, selectors);
    }

    function testErrorRecoverTokensWhenNotAdmin() external {
        vm.expectRevert(
            abi.encodeWithSelector(Ownable.OwnableUnauthorizedAccount.selector, address(this))
        );
        tokenExchangeSetIssuer.recoverTokens(weth, address(0x1), 1);
    }

    function testErrorWhenSendETH() external {
        vm.expectRevert(TokenExchangeSetIssuer.ETHNotAccepted.selector);
        payable(address(tokenExchangeSetIssuer)).transfer(1 ether);
    }

    function testApproveToken() external {
        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = pepe;
        address testUser = address(0x71);
        vm.prank(deployer);
        tokenExchangeSetIssuer.approveTokens(tokens, testUser, type(uint256).max);
        assertEq(pepe.allowance(address(tokenExchangeSetIssuer), testUser), type(uint256).max);
    }

    function testApproveTokenSetZero() external {
        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = pepe;
        address testUser = address(0x71);
        vm.startPrank(deployer);
        tokenExchangeSetIssuer.approveTokens(tokens, testUser, type(uint256).max);
        assertEq(pepe.allowance(address(tokenExchangeSetIssuer), testUser), type(uint256).max);
        tokenExchangeSetIssuer.approveTokens(tokens, testUser, 0);
        assertEq(pepe.allowance(address(tokenExchangeSetIssuer), testUser), 0);
    }

    function testAddSetTokenIssuanceModules() external {
        vm.startPrank(deployer);
        tokenExchangeSetIssuer.addSetTokenIssuanceModules(address(0x1), address(0x2));
        assertEq(tokenExchangeSetIssuer.setTokenIssuanceModules(address(0x1)), address(0x02));
    }

    function testRemoveTokenIssuanceModules() external {
        vm.startPrank(deployer);
        tokenExchangeSetIssuer.addSetTokenIssuanceModules(address(0x1), address(0x2));
        assertEq(tokenExchangeSetIssuer.setTokenIssuanceModules(address(0x1)), address(0x02));
        tokenExchangeSetIssuer.removeSetTokenIssuanceModules(address(0x1));
        assertEq(tokenExchangeSetIssuer.setTokenIssuanceModules(address(0x1)), address(0x0));
    }

    function _calculateFunctionIdentifier(address target, bytes4 selector) private pure returns(bytes24 identifier) {
        bytes memory encodedData = abi.encodePacked(target, selector);
        identifier = bytes24(encodedData);
    }

    function testWhiteListFunction() external {
        vm.startPrank(deployer);
        bytes24 identifier = bytes24(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D1f00ca74);
        bytes4[] memory selectors = new bytes4[](1);
        selectors[0] = IUniswapV2Router.getAmountsIn.selector;
        bytes24 calculatedIdentifier = _calculateFunctionIdentifier(uniswapRouterAddress, selectors[0]);
        assertEq(tokenExchangeSetIssuer.whitelistedFunctions(identifier), false);
        assertEq(tokenExchangeSetIssuer.whitelistedFunctions(calculatedIdentifier), false);
        tokenExchangeSetIssuer.whitelistFunctions(uniswapRouterAddress, selectors);
        assertEq(tokenExchangeSetIssuer.whitelistedFunctions(calculatedIdentifier), true);
        assertEq(tokenExchangeSetIssuer.whitelistedFunctions(identifier), true);
    }

    function testRevokeWhitelistedFunction() external {
        vm.startPrank(deployer);
        bytes24 identifier = bytes24(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D5c11d795);
        bytes4[] memory selectors = new bytes4[](1);
        selectors[0] = IUniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens.selector;
        bytes24 calculatedIdentifier = _calculateFunctionIdentifier(uniswapRouterAddress, selectors[0]);
        assertEq(tokenExchangeSetIssuer.whitelistedFunctions(identifier), true);
        assertEq(tokenExchangeSetIssuer.whitelistedFunctions(calculatedIdentifier), true);
        tokenExchangeSetIssuer.revokeWhitelistedFunctions(uniswapRouterAddress, selectors);
        assertEq(tokenExchangeSetIssuer.whitelistedFunctions(calculatedIdentifier), false);
        assertEq(tokenExchangeSetIssuer.whitelistedFunctions(identifier), false);

    }

    function testRecoverTokens() external {
        vm.prank(user);
        weth.transfer(address(tokenExchangeSetIssuer), 1 ether);
        assertEq(weth.balanceOf(address(tokenExchangeSetIssuer)), 1 ether);
        vm.startPrank(deployer);
        tokenExchangeSetIssuer.recoverTokens(weth, address(deployer), 1 ether);
        assertEq(weth.balanceOf(deployer), 1 ether);
        assertEq(weth.balanceOf(address(tokenExchangeSetIssuer)), 0);
    }

    function testEventFunctionWhitelisted() external {
        vm.startPrank(deployer);
        bytes4[] memory selectors = new bytes4[](1);
        selectors[0] = IUniswapV2Router.getAmountsIn.selector;
        vm.expectEmit(
            true,
            true,
            true,
            true,
            address(tokenExchangeSetIssuer)
        );
        emit TokenExchangeSetIssuer.FunctionWhitelisted(uniswapRouterAddress, selectors[0]);
        tokenExchangeSetIssuer.whitelistFunctions(uniswapRouterAddress, selectors);
    }

    function testEventFunctionRevoked() external {
        vm.startPrank(deployer);
        bytes4[] memory selectors = new bytes4[](1);
        selectors[0] = IUniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens.selector;
        vm.expectEmit(
            true,
            true,
            true,
            true,
            address(tokenExchangeSetIssuer)
        );
        emit TokenExchangeSetIssuer.FunctionRevoked(uniswapRouterAddress, selectors[0]);
        tokenExchangeSetIssuer.revokeWhitelistedFunctions(uniswapRouterAddress, selectors);
    }

    function testEventIssuanceModuleAdded() external {
        vm.startPrank(deployer);
        vm.expectEmit(
            true,
            true,
            true,
            true,
            address(tokenExchangeSetIssuer)
        );
        emit TokenExchangeSetIssuer.IssuanceModuleAdded(address(0x1), address(0x2));
        tokenExchangeSetIssuer.addSetTokenIssuanceModules(address(0x1), address(0x2));
    }

    function testEventIssuanceModuleRemoved() external {
        vm.startPrank(deployer);
        tokenExchangeSetIssuer.addSetTokenIssuanceModules(address(0x1), address(0x2));
        vm.expectEmit(
            true,
            true,
            true,
            true,
            address(tokenExchangeSetIssuer)
        );
        emit TokenExchangeSetIssuer.IssuanceModuleRemoved(address(0x1), address(0x2));
        tokenExchangeSetIssuer.removeSetTokenIssuanceModules(address(0x1));
    }
}
